# 24. 受入基準とチェックリスト

**最終更新**: 2025-01-07
**カテゴリ**: 開発手法・プラクティス（設計フェーズ）
**難易度**: ⭐⭐ (初級〜中級)

## 📋 目次

1. [概要](#概要)
2. [受入基準（Acceptance Criteria）とは](#受入基準acceptance-criteriaとは)
3. [Definition of Done（完成の定義）との違い](#definition-of-done完成の定義との違い)
4. [AI駆動開発における重要性](#ai駆動開発における重要性)
5. [受入基準の書き方](#受入基準の書き方)
6. [2つのフォーマット](#2つのフォーマット)
7. [チェックリスト形式 vs シナリオ形式](#チェックリスト形式-vs-シナリオ形式)
8. [Java/Spring Boot開発での実例](#javaspring-boot開発での実例)
9. [AI問題への対策](#ai問題への対策)
10. [ベストプラクティス](#ベストプラクティス)
11. [アンチパターン](#アンチパターン)
12. [まとめ](#まとめ)
13. [参考資料](#参考資料)

---

## 概要

### 受入基準とは

**受入基準（Acceptance Criteria、AC）**は、ユーザーストーリーが「完成した」と判断するための具体的な条件です。

**例**:
```
ユーザーストーリー:
「会員として、商品をカートに追加したい。
なぜなら、後でまとめて購入できるようにするためだ。」

受入基準:
✓ カート追加ボタンをクリックすると、カートアイコンのバッジ数が+1される
✓ 「カートに追加しました」というトースト通知が表示される
✓ 同じ商品を再度追加した場合、数量が+1される（重複行は作らない）
✓ 在庫がない商品は「在庫切れ」ボタンが無効化される
```

### なぜ必要か

1. **曖昧さの排除**
   - 「カート機能を作って」だけでは、AIも人間も何を作るべきか分からない
   - 受入基準で「何ができればOKか」を明確化

2. **完了判定の基準**
   - プロダクトオーナー: 「この条件を満たせば受け入れる」
   - 開発者: 「この条件を満たせば完了」
   - QA: 「この条件でテストする」

3. **AI開発での重要性**
   - **Reward Hacking対策**: 手抜き防止（最低限の実装だけで完了としない）
   - **Scope Creep対策**: 暴走防止（受入基準にない機能は実装しない）
   - **自動テスト生成**: 受入基準→E2Eテストに変換可能

---

## 受入基準（Acceptance Criteria）とは

### 定義

**Scrum.orgの定義**:
> "Acceptance Criteria are the specific, measurable requirements that a user story, feature, or project must meet to be accepted by the Product Owner or client."
> （受入基準は、ユーザーストーリー、機能、またはプロジェクトがプロダクトオーナーまたはクライアントに受け入れられるために満たすべき、具体的で測定可能な要件です。）

### 特徴

| 特徴 | 説明 | 例 |
|------|------|-----|
| **具体的** | 曖昧な表現を避ける | ❌「使いやすい」→ ✅「検索結果が0.5秒以内に表示される」 |
| **測定可能** | Yes/No で判定できる | ❌「快適に動作する」→ ✅「100件の商品を1秒以内に表示する」 |
| **テスト可能** | E2Eテストで検証可能 | ✅「カートボタンをクリックすると、バッジ数が+1される」 |
| **客観的** | 主観に依らない | ❌「デザインが美しい」→ ✅「ボタンの高さは44px以上（タップしやすさ基準）」 |

### 受入基準の5つのポイント

**プロダクトマネジメントの要諦**より:

1. **Yes/Noで判定可能**
   - 「できた」「できていない」が明確

2. **定量的**
   - 数値で測定可能

3. **客観的に検証可能**
   - 誰が見ても同じ判定

4. **機能要件と非機能要件の両方**
   - 機能: 「何ができるか」
   - 非機能: 「どれだけ速いか、安全か」

5. **ストーリー完了のチェックリスト**
   - すべての項目を満たして初めて完了

---

## Definition of Done（完成の定義）との違い

### 比較表

| 項目 | 受入基準（AC） | Definition of Done（DoD） |
|------|---------------|--------------------------|
| **適用範囲** | 個別のユーザーストーリー | すべてのプロダクトバックログアイテム |
| **内容** | 「この機能が何をするか」 | 「品質基準、プロセス」 |
| **誰が定義** | プロダクトオーナー＋チーム | チーム全体 |
| **いつ定義** | ストーリーごとに定義 | プロジェクト開始時に定義 |
| **変更頻度** | ストーリーごとに異なる | プロジェクト期間中は固定（定期見直し） |

### 例

**受入基準（US-003: カート追加）**:
```
✓ カート追加ボタンをクリックすると、カートアイコンのバッジ数が+1される
✓ 「カートに追加しました」というトースト通知が表示される
✓ 同じ商品を再度追加した場合、数量が+1される
```

**Definition of Done（すべてのストーリーに共通）**:
```
✓ コードレビュー完了
✓ 単体テストカバレッジ80%以上
✓ E2Eテスト作成・成功
✓ CheckStyle警告0件
✓ セキュリティ脆弱性スキャン実施
✓ ドキュメント更新（README, ADR）
✓ mainブランチにマージ
```

### 両方を満たして初めて完了

```
ユーザーストーリー完了 = 受入基準（AC）を満たす ∧ Definition of Done（DoD）を満たす
```

**例**:
```
US-003: カート追加

受入基準:
✅ カートバッジ数+1される
✅ トースト通知表示
✅ 重複時は数量+1

Definition of Done:
✅ コードレビュー完了
✅ テストカバレッジ85%
✅ CheckStyle警告0件
✅ E2Eテスト成功
✅ ドキュメント更新

→ すべて満たして初めて「完了」
```

---

## AI駆動開発における重要性

### AI問題と受入基準

| AI問題 | 受入基準による対策 | 具体例 |
|-------|------------------|--------|
| **Reward Hacking（手抜き）** | 詳細な受入基準で手抜きを防ぐ | ❌「カート機能を作って」→ AIがボタンだけ作る<br>✅ 受入基準で「バッジ数更新」「トースト通知」「重複チェック」を明記 → すべて実装 |
| **Scope Creep（暴走）** | 受入基準にない機能は実装しない | ❌「カート機能」→ AIがクーポン・ポイント機能も追加<br>✅ 受入基準に「カート追加のみ」明記 → 余計な機能を実装しない |
| **Hallucination（虚偽）** | 具体的な条件で虚偽報告を検証 | ❌「カート機能を実装しました」→ 実際は未実装<br>✅ 受入基準で「バッジ数が+1されること」→ E2Eテストで自動検証 |
| **Context Limitations（忘れっぽさ）** | 受入基準をGit管理で外部化 | Compact後も `docs/user-stories/US-003-cart-add.md` を参照可能 |

### Trust but Verifyとの関係

```
Layer 0（事前防止）: 受入基準でガードレール設定
  ↓
Layer 1（自動検証）: 受入基準 → E2Eテスト自動生成
  ↓
Layer 2（AI自己検証）: 「受入基準を満たしているか確認してください」
  ↓
Layer 3（人間レビュー）: 受入基準チェックリストでレビュー
```

---

## 受入基準の書き方

### 基本ルール

1. **箇条書き形式**
   - チェックボックス（✓）で管理

2. **1項目 = 1つの検証可能な条件**
   - 複数の条件を1項目にまとめない

3. **肯定形で書く**
   - ❌「エラーが発生しない」
   - ✅「正常に処理が完了する」

4. **「〜すること」「〜される」で終わる**
   - 明確な動作を記述

5. **優先度を明記（必要に応じて）**
   - MUST（必須）/ SHOULD（推奨）/ MAY（任意）

### 5つの観点

**SmartHR Tech Blogより**:

1. **機能要件**
   - 「何ができるか」

2. **非機能要件**
   - パフォーマンス、セキュリティ、可用性

3. **正常系**
   - 通常の操作フロー

4. **異常系・エラーケース**
   - 不正入力、ネットワークエラー、権限不足

5. **境界値**
   - 最小値・最大値・0件・大量データ

---

## 2つのフォーマット

### 1. シナリオ形式（Given-When-Then）

**BDD（Behavior-Driven Development）形式**

```
受入基準:

Scenario 1: 商品をカートに追加する（正常系）
- GIVEN: 会員ログイン済み、商品詳細ページを表示
- WHEN: 「カートに追加」ボタンをクリック
- THEN: カートアイコンのバッジ数が+1される
- AND: 「カートに追加しました」というトースト通知が表示される

Scenario 2: 同じ商品を再度追加する
- GIVEN: 商品A がすでにカートに1個追加済み
- WHEN: 商品A の詳細ページで再度「カートに追加」ボタンをクリック
- THEN: カート内の商品A の数量が2になる
- AND: カートの合計商品数が+1される

Scenario 3: 在庫切れ商品の場合
- GIVEN: 商品B の在庫数が0
- WHEN: 商品B の詳細ページを表示
- THEN: 「カートに追加」ボタンが無効化される
- AND: 「在庫切れ」と表示される
```

**メリット**:
- 操作フローが明確
- E2Eテスト（Playwright, Cucumber）に変換しやすい
- 複雑な条件分岐を表現可能

**デメリット**:
- 記述量が多い
- シンプルな機能には冗長

### 2. ルール/チェックリスト形式

**箇条書き形式**

```
受入基準:

機能要件:
✓ カート追加ボタンをクリックすると、カートアイコンのバッジ数が+1される
✓ 「カートに追加しました」というトースト通知が3秒間表示される
✓ 同じ商品を再度追加した場合、カート内の数量が+1される（重複行は作らない）
✓ 在庫がない商品は「在庫切れ」ボタンが無効化される

非機能要件:
✓ カート追加処理が0.5秒以内に完了する
✓ 同時に100ユーザーがカート追加してもエラーが発生しない

エラーケース:
✓ 未ログイン状態でカート追加ボタンをクリックすると、ログイン画面にリダイレクトされる
✓ ネットワークエラー時、「通信エラーが発生しました」とエラーメッセージが表示される
```

**メリット**:
- 簡潔で読みやすい
- レビューしやすい
- チェックリストとしてそのまま使える

**デメリット**:
- 複雑な条件分岐を表現しにくい
- 操作順序が不明確

---

## チェックリスト形式 vs シナリオ形式

### 使い分け

| ケース | 推奨形式 | 理由 |
|--------|---------|------|
| シンプルなCRUD操作 | チェックリスト形式 | 簡潔で十分 |
| 複雑な業務フロー | シナリオ形式（Given-When-Then） | 操作順序・条件分岐を明確化 |
| E2Eテスト自動生成 | シナリオ形式 | Playwright/Cucumberに変換しやすい |
| レビュー会議 | チェックリスト形式 | 一覧性が高い |

### 併用パターン

**asoview! Tech Blog**（2024年12月）の実例:

```
US-003: カート追加

## 受入基準（チェックリスト形式）

機能要件:
✓ カート追加ボタンをクリックすると、カートバッジ数が+1される
✓ トースト通知「カートに追加しました」が表示される
✓ 同じ商品を再度追加すると、数量が+1される

## 詳細シナリオ（Given-When-Then形式）

### Scenario 1: 初めて商品をカートに追加
- GIVEN: カートが空、商品詳細ページを表示
- WHEN: 「カートに追加」ボタンをクリック
- THEN: カートバッジ数が「1」になる
- AND: トースト通知が表示される

### Scenario 2: 同じ商品を再度追加
- GIVEN: 商品A がカートに1個追加済み
- WHEN: 商品A の詳細ページで「カートに追加」ボタンをクリック
- THEN: カート内の商品A の数量が「2」になる
- AND: カートバッジ数が「2」になる
```

---

## Java/Spring Boot開発での実例

### ケーススタディ: ECサイトのカート機能

#### US-003: カート追加機能

**ユーザーストーリー**:
```
会員として、
商品詳細ページで「カートに追加」ボタンをクリックしたい。
なぜなら、後でまとめて購入できるようにするためだ。
```

**受入基準（チェックリスト形式）**:

```markdown
## 機能要件

### 正常系
- [ ] カート追加ボタンをクリックすると、カートアイコンのバッジ数が+1される
- [ ] 「カートに追加しました」というトースト通知が3秒間表示される
- [ ] 同じ商品を再度追加した場合、カート内の数量が+1される（重複行は作らない）
- [ ] カート追加後、商品詳細ページはそのまま表示される（画面遷移しない）

### 異常系
- [ ] 未ログイン状態でカート追加ボタンをクリックすると、ログイン画面にリダイレクトされる
- [ ] 在庫がない商品は「カートに追加」ボタンが無効化され、「在庫切れ」と表示される
- [ ] ネットワークエラー時、「通信エラーが発生しました。もう一度お試しください。」とエラーメッセージが表示される
- [ ] サーバーエラー時、「エラーが発生しました。しばらくしてからお試しください。」と表示される

### 境界値
- [ ] カート内の同一商品の数量上限は99個（100個目の追加時は「数量上限に達しました」と表示）
- [ ] 在庫数が5個の商品を6個カートに追加しようとすると、「在庫数を超える追加はできません」と表示

## 非機能要件

### パフォーマンス
- [ ] カート追加処理が0.5秒以内に完了する（95パーセンタイル）
- [ ] 同時に100ユーザーがカート追加してもエラーが発生しない

### セキュリティ
- [ ] 他人のカートに商品を追加できない（ユーザーID検証）
- [ ] CSRF トークンによる二重送信防止

### ユーザビリティ
- [ ] カート追加ボタンのローディング中は、ボタンが無効化されスピナーが表示される
- [ ] トースト通知は画面右上に表示され、×ボタンで手動で閉じられる

## UI要件

- [ ] カート追加ボタンのサイズ: 幅100%、高さ48px（モバイル）、44px（デスクトップ）
- [ ] カート追加ボタンの色: Primary色（#FF6B00）、ホバー時は10%明るく
- [ ] トースト通知の位置: 画面右上から16pxの位置
- [ ] バッジの背景色: 赤（#E53935）、白文字、円形
```

**詳細シナリオ（Given-When-Then形式）**:

```markdown
## Scenario 1: 初めて商品をカートに追加（正常系）

- **GIVEN**: 会員ログイン済み、カートが空、商品詳細ページ（商品ID: 123）を表示
- **WHEN**: 「カートに追加」ボタンをクリック
- **THEN**: カートアイコンのバッジ数が「1」になる
- **AND**: トースト通知「カートに追加しました」が画面右上に3秒間表示される
- **AND**: カート追加ボタンが0.5秒間無効化される（二重送信防止）

## Scenario 2: 同じ商品を再度追加

- **GIVEN**: 商品ID: 123 がカートに数量1で追加済み
- **WHEN**: 商品ID: 123 の詳細ページで「カートに追加」ボタンをクリック
- **THEN**: カート内の商品ID: 123 の数量が「2」になる
- **AND**: カートバッジ数が「2」になる
- **AND**: トースト通知「カートに追加しました（数量: 2）」が表示される

## Scenario 3: 在庫切れ商品の場合

- **GIVEN**: 商品ID: 456 の在庫数が0
- **WHEN**: 商品ID: 456 の詳細ページを表示
- **THEN**: 「カートに追加」ボタンが無効化される（disabled属性）
- **AND**: ボタンのテキストが「在庫切れ」に変わる
- **AND**: ボタンの背景色がグレー（#CCCCCC）になる

## Scenario 4: 未ログイン状態でカート追加を試みる

- **GIVEN**: 未ログイン状態、商品詳細ページを表示
- **WHEN**: 「カートに追加」ボタンをクリック
- **THEN**: ログイン画面（/login）にリダイレクトされる
- **AND**: ログイン後、元の商品詳細ページにリダイレクトバックされる
- **AND**: トースト通知「ログインしてください」が表示される

## Scenario 5: 数量上限に達した場合

- **GIVEN**: 商品ID: 123 がカートに数量99で追加済み
- **WHEN**: 商品ID: 123 の詳細ページで「カートに追加」ボタンをクリック
- **THEN**: カート内の数量は99のまま（変更されない）
- **AND**: エラーメッセージ「数量上限（99個）に達しました」が表示される
- **AND**: 「カートに追加」ボタンが無効化される

## Scenario 6: 在庫数を超える追加の場合

- **GIVEN**: 商品ID: 789 の在庫数が5個、カートに4個追加済み
- **WHEN**: 商品ID: 789 の詳細ページで「カートに追加」ボタンをクリック（2回）
- **THEN**: 1回目のクリックで数量が5になる
- **AND**: 2回目のクリックで「在庫数（5個）を超える追加はできません」と表示される
- **AND**: カート内の数量は5のまま
```

### Spring Boot実装への変換

**Claude Codeへのプロンプト**:

```
以下のユーザーストーリーと受入基準を元に、Spring Boot + Thymeleafで実装してください。

**ユーザーストーリー**: US-003（docs/user-stories/US-003-cart-add.md）

**受入基準**: 上記の機能要件・非機能要件・UIをすべて満たすこと

**技術スタック**:
- Spring Boot 3.2
- Spring Security（ログイン状態確認）
- Spring Data JPA
- Thymeleaf + Bootstrap 5
- JavaScript（トースト通知、バッジ更新）

**実装要件**:
1. CartController#addItem() を実装
2. CartService#addItem() を実装（在庫チェック、数量上限チェック）
3. Cart.java, CartItem.java エンティティを実装
4. products/detail.html にカート追加ボタンを実装
5. 受入基準の「Scenario 1〜6」をすべて満たすこと
6. E2Eテスト（Playwright）を受入基準から自動生成してください

**実装しないこと**:
- 決済機能（US-010で別途実装）
- クーポン機能（US-011で別途実装）
- ゲスト購入（US-012で別途実装）
```

---

## AI問題への対策

### 1. Reward Hacking（手抜き）対策

**問題**: AIが最低限の実装だけして「完了しました」と報告

**対策**: 受入基準を詳細に記載

**悪い例**:
```
受入基準:
✓ カート機能を実装すること
```

→ AIは「カート追加ボタン」だけ作って完了と報告する可能性。

**良い例**:
```
受入基準:
✓ カート追加ボタンをクリックすると、カートバッジ数が+1される
✓ トースト通知「カートに追加しました」が3秒間表示される
✓ 同じ商品を再度追加すると、数量が+1される（重複行は作らない）
✓ 在庫切れ商品は「カートに追加」ボタンが無効化される
✓ 未ログイン時はログイン画面にリダイレクトされる
✓ カート追加処理が0.5秒以内に完了する
```

→ すべての項目を実装しないと完了にならない。

### 2. Scope Creep（暴走）対策

**問題**: AIが受入基準にない機能を勝手に実装

**対策**: 「実装しないこと」を明記

**例**:
```
受入基準:
（機能要件は上記の通り）

実装しないこと:
✗ クーポン適用機能（US-011で別途実装）
✗ ポイント付与機能（US-013で別途実装）
✗ お気に入り登録機能（US-014で別途実装）
✗ カート内容のメール送信（US-015で別途実装）
```

### 3. Hallucination（虚偽報告）対策

**問題**: AIが「受入基準を満たしました」と虚偽報告

**対策**: 受入基準→E2Eテスト自動生成

**プロンプト**:
```
「受入基準（docs/user-stories/US-003-cart-add.md）から、
Playwright E2Eテストを自動生成してください。

Scenario 1〜6のすべてをテストケースとして実装してください。
テストが成功したら、受入基準を満たしていると判断します。」
```

→ AIの報告ではなく、**自動テストの成功**で検証。

### 4. Context Limitations（忘れっぽさ）対策

**問題**: Compact後、受入基準の情報が失われる

**対策**: 受入基準をGit管理で外部化

**ディレクトリ構成**:
```bash
docs/
└── user-stories/
    ├── US-001-product-list.md
    ├── US-002-product-search.md
    └── US-003-cart-add.md
        ├── ユーザーストーリー
        ├── 受入基準（チェックリスト形式）
        └── 詳細シナリオ（Given-When-Then形式）
```

**プロンプト**:
```
「docs/user-stories/US-003-cart-add.md を参照して、
カート追加機能を実装してください。
受入基準をすべて満たすことを確認してください。」
```

---

## ベストプラクティス

### 1. 機能要件と非機能要件の両方を記載

**機能要件**:
```
✓ カート追加ボタンをクリックすると、バッジ数が+1される
```

**非機能要件**:
```
✓ カート追加処理が0.5秒以内に完了する（パフォーマンス）
✓ 同時100ユーザーでもエラーが発生しない（可用性）
✓ 他人のカートに追加できない（セキュリティ）
```

### 2. 正常系・異常系・境界値の3つをカバー

**正常系**:
```
✓ 商品をカートに追加すると、バッジ数が+1される
```

**異常系**:
```
✓ 在庫切れ商品は「カートに追加」ボタンが無効化される
✓ 未ログイン時はログイン画面にリダイレクト
```

**境界値**:
```
✓ 数量上限99個（100個目の追加時はエラー）
✓ カートが空の状態から1個追加（バッジ数が0→1）
```

### 3. UI仕様も受入基準に含める

**例**:
```
UI要件:
✓ カート追加ボタンのサイズ: 幅100%、高さ48px（モバイル）
✓ トースト通知の位置: 画面右上から16px
✓ バッジの背景色: 赤（#E53935）、白文字
✓ ローディング中はスピナーを表示し、ボタンを無効化
```

### 4. E2Eテスト自動生成を前提に書く

**Given-When-Then形式**:
```
Scenario 1: 商品をカートに追加
- GIVEN: 会員ログイン済み、商品詳細ページを表示
- WHEN: 「カートに追加」ボタンをクリック
- THEN: カートバッジ数が+1される
```

→ このままPlaywright/Cucumberテストに変換可能。

### 5. プロダクトオーナーと開発者で合意

**レビュー会議**:
```
1. ユーザーストーリーを読み上げ
2. 受入基準（チェックリスト）を1項目ずつ確認
3. 「この条件で完了判定してOKか？」を合意
4. 不足している条件があれば追加
```

---

## アンチパターン

### アンチパターン1: 曖昧な受入基準

**Bad**:
```
✓ カート機能が使いやすいこと
✓ パフォーマンスが良好なこと
✓ デザインが美しいこと
```

**Good**:
```
✓ カート追加ボタンをクリックすると、0.5秒以内にバッジ数が更新される
✓ カート追加処理が95パーセンタイルで0.5秒以内に完了する
✓ カート追加ボタンの高さは44px以上（タップしやすさ基準）
```

### アンチパターン2: 実装方法を書いてしまう

**Bad**:
```
✓ CartServiceのaddItem()メソッドで、CartRepositoryのsave()を呼び出すこと
✓ JPA @Transactionalアノテーションを付与すること
```

**Good**:
```
✓ カート追加処理がトランザクション内で完了すること（ロールバック保証）
✓ 同時更新時、楽観的ロックで競合を検出すること
```

→ 「何を実装するか」は書かない。「どうなるべきか」を書く。

### アンチパターン3: 1項目に複数条件を詰め込む

**Bad**:
```
✓ カート追加ボタンをクリックすると、バッジ数が+1され、トースト通知が表示され、同じ商品の場合は数量が増える
```

**Good**:
```
✓ カート追加ボタンをクリックすると、バッジ数が+1される
✓ トースト通知「カートに追加しました」が3秒間表示される
✓ 同じ商品を再度追加すると、数量が+1される
```

### アンチパターン4: テスト不可能な条件

**Bad**:
```
✓ ユーザーが満足すること
✓ 直感的に操作できること
```

**Good**:
```
✓ カート追加ボタンのタップ領域が44px×44px以上（iOS Human Interface Guidelines基準）
✓ カート追加処理が0.5秒以内に完了する（ユーザー満足度調査で「速い」と評価される基準）
```

---

## まとめ

### 受入基準の重要ポイント

1. **具体的・測定可能・テスト可能**
   - 曖昧な表現を避ける
   - Yes/Noで判定できる

2. **機能要件＋非機能要件**
   - パフォーマンス、セキュリティ、ユーザビリティも記載

3. **正常系・異常系・境界値**
   - すべてのケースをカバー

4. **Definition of Doneと組み合わせる**
   - 受入基準（機能）+ DoD（品質・プロセス）= 完了

5. **AI駆動開発での活用**
   - Reward Hacking対策: 詳細な条件で手抜き防止
   - Scope Creep対策: 「実装しないこと」明記
   - 自動テスト生成: Given-When-Then形式

### 開発フェーズでの位置づけ

```
要件定義フェーズ:
1. ユーザーストーリー作成（23-user-story-writing.md）
   ↓
設計フェーズ:
2. 受入基準を箇条書きでまとめ（本記事）
   ↓
タスク分解フェーズ:
3. GIVEN WHEN THEN形式のBDDテストシナリオ定式化（01-given-when-then-bdd.md）
   ↓
実装フェーズ:
4. E2Eテスト自動生成（受入基準から）
5. TDD（02-test-driven-development-tdd.md）
```

---

## 参考資料

### 公式ドキュメント・ガイド

1. **Scrum.org**
   - [What Is the Difference Between the Definition of Done and Acceptance Criteria?](https://www.scrum.org/resources/blog/what-difference-between-definition-done-and-acceptance-criteria)
   - [Acceptance Criteria & Definition of done](https://www.scrum.org/forum/scrum-forum/17103/acceptance-criteria-definition-done)

2. **Visual Paradigm**
   - [Definition of Done vs Acceptance Criteria](https://www.visual-paradigm.com/scrum/definition-of-done-vs-acceptance-criteria/)

3. **Nulab**
   - [Definition of Done vs. Acceptance Criteria: A complete guide](https://nulab.com/learn/software-development/definition-of-done-vs-acceptance-criteria/)

4. **Agile Sherpas**
   - [Definition of Done vs Acceptance Criteria (and Why Your Team Needs Both)](https://www.agilesherpas.com/blog/definition-of-done-acceptance-criteria)

### 技術記事・ブログ

5. **SmartHR Tech Blog** (2019)
   - [スクラムをうまく回すために受け入れ基準をきちんと書く](https://tech.smarthr.jp/entry/2019/01/10/122048)

6. **asoview! Tech Blog** (2024年12月)
   - [受入基準（Acceptance Criteria）の導入。スクラムチームにおける開発者とQAの融合への挑戦](https://tech.asoview.co.jp/entry/2024/12/05/100000)
   - シナリオ形式（Given/When/Then）とルール形式（チェックリスト）の2つのフォーマットを紹介
   - 受入基準導入後、不具合が減少し品質が向上

7. **日本語リソース**
   - [【プラクティス紹介】1分でさらっと分かる「受け入れ条件」](https://qiita.com/kakashi_h5/items/46cb60496ff9702dde35) - Qiita
   - [アジャイルユーザーストーリーの受入基準5つのポイント](https://rihoublog.com/2018/11/06/アジャイルユーザーストーリーの受入基準5つのポ/) - プロダクトマネジメントの要諦
   - [開発チームが喜ぶ「受け入れ基準」の書き方](https://note.com/pmsan/n/n1ca8a121e95c) - note

8. **英語リソース**
   - [How to Create Effective Acceptance Criteria for Your Team](https://clickup.com/blog/how-to-write-acceptance-criteria/) - ClickUp
   - [アジャイルテストの受け入れ条件](https://blog.testrail.techmatrix.jp/acceptance-criteria-agile/) - TestRail Blog

### 関連トピック

- [01. GIVEN WHEN THEN - BDD形式の受入条件](./01-given-when-then-bdd.md)
- [23. ユーザーストーリーの書き方](./23-user-story-writing.md)（前の記事）
- [25. タスク分解とトークン制限への対応](./25-task-decomposition.md)（次の記事）
- [13. Reward Hacking in AI](./13-reward-hacking-ai.md)
- [16. AI Scope Creep（暴走）](./16-ai-scope-creep.md)
- [18. Trust but Verify（任せる＆確かめる）](./18-trust-but-verify.md)

---

**次のトピック**: [25. タスク分解とトークン制限への対応](./25-task-decomposition.md)
**前のトピック**: [23. ユーザーストーリーの書き方](./23-user-story-writing.md)

---

**📝 更新履歴**:
- 2025-01-07: 初版作成（WEB検索による最新情報反映）

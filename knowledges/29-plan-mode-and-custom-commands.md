# Planモードとカスタムコマンドによる早期軌道修正

## 概要

AI駆動開発において、大きな作業をする際に**Planモード**と**カスタムコマンド**を活用することで、AIの思考を早い段階で言語化し、人間がレビューして問題ない場合にだけ前に進めることができる。これにより早期に軌道修正が可能になり、結果として開発速度が大幅に向上する。

## なぜPlanモードとカスタムコマンドが必要なのか

### AI の問題: 予期しない方向に進む

AIは人間が予期したのとは違うことをすることが多い。特に大きな作業では：

- **暴走（Scope Creep）**: 実装範囲が膨らむ
- **手抜き（Reward Hacking）**: ハードコード実装で済ませる
- **誤解釈**: 要件を独自解釈して、意図しない実装をする

### 従来の問題: 実装後に気づく

```
人間: 「ユーザー管理機能を実装してください」
AI: 「了解しました！実装します」
   ↓ (30分後)
AI: 「完成しました！」
人間: 「レビュー...あれ？これは要らない機能だし、これは違う実装だ...」
人間: 「ここを修正してください」
AI: 「了解しました！修正します」
   ↓ (15分後)
AI: 「修正完了しました！」
人間: 「レビュー...まだ違う...」

【結果】: 2時間以上の手戻り
```

### Planモードとカスタムコマンドの解決策: 実装前に気づく

```
人間: 「ユーザー管理機能を実装してください」
AI: 「実装計画を立てます...」
   ↓ (1分後)
AI: 「実装計画:
    1. ユーザー作成機能
    2. ユーザー一覧機能
    3. ユーザー更新機能
    4. ユーザー削除機能
    5. ユーザー検索機能  ← 不要
    6. ユーザーエクスポート機能 ← 不要
    7. メール通知機能 ← 不要（別タスク）

    この計画で進めてよろしいですか？」

人間: 「5, 6, 7は不要です。1-4のみ実装してください」
AI: 「了解しました。1-4のみ実装します」
   ↓ (25分後)
AI: 「完成しました！」
人間: 「レビュー...OK！」

【結果】: 手戻りなし、30分で完了
```

**効果**: 早い段階で軌道修正できるため、開発速度が2〜3倍速くなる。

## Planモードとは

### 定義

**Planモード**は、実装前にAIに計画を立てさせ、人間が承認してから実装に進むモード。

Claude Codeでは、実装指示の前に「まず計画を立ててください」と明示的に依頼する。

### 使い方

#### パターン1: 明示的な計画依頼

```
「ユーザー管理機能を実装してください。

まず、以下の形式で実装計画を立ててください:
1. 実装する機能のリスト
2. 変更するファイルのリスト
3. 新規作成するファイルのリスト
4. テスト戦略
5. 想定される課題

計画を承認してから実装を開始してください。」
```

#### パターン2: カスタムコマンドで自動化

**`.claude/commands/plan.md`**:
```markdown
以下の手順で実装計画を立ててください:

## 1. 要件の確認
- GitHub issueまたはユーザーからの指示を確認
- 曖昧な点があれば質問する

## 2. 実装計画の作成
以下の形式で計画を提示:

### 実装する機能
- [ ] 機能1
- [ ] 機能2
- [ ] 機能3

### 実装しない機能（スコープ外）
- ❌ 機能X（理由: ...）
- ❌ 機能Y（理由: ...）

### 変更するファイル
- `src/main/java/com/example/controller/UserController.java` - ユーザー作成エンドポイント追加
- `src/main/java/com/example/service/UserService.java` - ビジネスロジック実装

### 新規作成するファイル
- `src/main/java/com/example/dto/CreateUserRequest.java` - リクエストDTO
- `src/main/java/com/example/dto/UserResponse.java` - レスポンスDTO

### テスト戦略
- UserServiceのユニットテスト（@DataJpaTest）
- UserControllerの統合テスト（@SpringBootTest）
- 受入条件に対する E2E テスト

### 想定される課題
- 重複メールアドレスのハンドリング
- パスワードのバリデーション

### 所要時間見積もり
- 実装: 20分
- テスト: 15分
- 合計: 35分

## 3. 承認待ち
「この計画で進めてよろしいですか？」と質問し、承認を待つ。

承認後に実装を開始する。
```

**使用方法**:
```
/plan ユーザー管理機能を実装
```

### Planモードのメリット

1. **早期軌道修正**: 実装前に方向性を確認できる
2. **スコープ明確化**: 「実装するもの」「実装しないもの」が明確
3. **手戻り削減**: 不要な実装を避けられる
4. **見積もり精度向上**: 事前に所要時間を把握
5. **暴走防止**: Scope Creepを事前に防ぐ

## カスタムコマンドとは

### 定義

**カスタムコマンド**は、頻繁に使う指示を`.claude/commands/`ディレクトリにMarkdownファイルとして保存し、スラッシュコマンドで呼び出せる機能。

### 活用パターン

#### パターン1: `/plan` - 実装計画

上記の「Planモード」を参照。

#### パターン2: `/implement` - 実装実行

**`.claude/commands/implement.md`**:
```markdown
新しい機能を実装する際は、以下の手順に従うこと:

## 1. ドキュメント確認
- [ ] CLAUDE.mdを確認
- [ ] 関連するADRを確認
- [ ] GitHub issueの仕様を確認

## 2. 実装計画の提示
実装前に、以下を含む計画を提示:
- 実装する機能のリスト
- 変更するファイルのリスト
- 新規作成するファイルのリスト
- テスト戦略

## 3. 承認待ち
「この計画で進めてよろしいですか？」と質問。

## 4. 実装開始
承認後、以下の順序で実装:

### 4.1. テストファースト（Red Phase）
- 失敗するテストを書く
- テストが失敗することを確認

### 4.2. 実装（Green Phase）
- テストを通す最小限の実装
- テストが成功することを確認

### 4.3. リファクタリング（Refactor Phase）
- コードの品質を向上
- テストが通ることを確認

### 4.4. 自己レビュー
実装完了後、以下をチェック:
- [ ] CLAUDE.mdのルールに準拠しているか
- [ ] すべてのテストが通るか
- [ ] 受入条件を満たしているか
- [ ] コンパイルエラーがないか
- [ ] 循環的複雑度が10以下か

## 5. 完成度自己評価
「今回の実装の完成度を0-100点で評価してください。未実装の項目があれば指摘してください。」

100点になるまで繰り返す。
```

**使用方法**:
```
/implement #123
```

#### パターン3: `/verify` - 完成度検証

**`.claude/commands/verify.md`**:
```markdown
以下の観点で、現在の実装の完成度を0-100点で評価してください:

## 1. 受入条件の充足
- [ ] すべての受入条件を満たしているか
- [ ] GIVEN-WHEN-THENシナリオがすべて動作するか

## 2. テストカバレッジ
- [ ] すべてのテストが通るか
- [ ] カバレッジ目標を達成しているか（Serviceレイヤー 80%以上）

## 3. コード品質
- [ ] CLAUDE.mdのルールに準拠しているか
- [ ] 循環的複雑度が10以下か
- [ ] 重複コードがないか
- [ ] dead codeがないか

## 4. ドキュメント
- [ ] JavaDocが書かれているか
- [ ] README更新が必要な場合、更新されているか

## 5. セキュリティ
- [ ] SQLインジェクション対策がされているか
- [ ] XSS対策がされているか
- [ ] 認証・認可が適切か
- [ ] パスワードが平文保存されていないか

## 評価結果
点数: X点 / 100点

### 満たしている項目
- ✅ 項目1
- ✅ 項目2

### 満たしていない項目
- ❌ 項目3: 理由...
- ❌ 項目4: 理由...

### 改善提案
1. 項目3を改善する方法: ...
2. 項目4を改善する方法: ...

**100点になるまで繰り返してください。**
```

**使用方法**:
```
/verify
```

#### パターン4: `/refactor` - リファクタリング

**`.claude/commands/refactor.md`**:
```markdown
以下の7つの質問に答えながら、リファクタリングを実行してください:

## ①技術的負債を見付けて

このプロジェクトの技術的負債を見付けて。特に以下を重点的に:
1. Cyclomatic Complexity 10以上のメソッド
2. 重複コード（3行以上の類似コード）
3. 使われていないメソッド・変数（dead code）
4. 例外処理が不足している箇所
5. JavaDocがないpublicメソッド

優先度P0（即座に対応）、P1（今週中）、P2（来週以降）で分類してください。

## ②冗長・重複・dead codeを削除して

冗長・重複・dead codeを削除して。テストは壊さないで。

## ③循環的複雑度を減らして

循環的複雑度を減らして。Complexity 10以上のメソッドをリストアップして、Extract MethodとGuard Clauseでリファクタリング。

## ④効果的にライブラリを活用できる箇所は

効果的にライブラリを活用できる箇所を見付けて。Apache Commons、Guava、Lombok等の活用箇所を提案して。

## ⑤効果的にデザインパターンを活用できる箇所は

効果的にデザインパターンを活用できる箇所を見付けて。過剰な適用は避けて。

## ⑥JavaDoc を書いて

全publicメソッドにJavaDocを書いて。

## ⑦arc42 と C4 Model を採用した ADR を書いて

[今回の技術的決定]のADRを、arc42とC4 Modelで作って。

## 完成度検証

「今回のリファクタリングの完成度を0-100点で評価して。未実装の項目があれば指摘して」

100点になるまで繰り返す。
```

**使用方法**:
```
/refactor
```

### カスタムコマンドのメリット

1. **再現性**: 同じ手順を毎回実行できる
2. **標準化**: チーム全体で統一された手順
3. **効率化**: 長い指示を毎回書く必要がない
4. **品質保証**: 必須チェック項目を漏らさない
5. **忘却防止**: Context Limitationsによる忘れっぽさを克服

## AIの思考の早期言語化

### 問題: AIの頭の中が見えない

従来の開発フロー:
```
人間: 「機能Xを実装してください」
   ↓
AI: （頭の中で計画）
   ↓ (30分間、人間は何も見えない)
AI: 「完成しました！」
   ↓
人間: 「レビュー...違う！」
```

**問題点**:
- AIが何を考えているか分からない
- 30分後に初めて問題に気づく
- 手戻りが大きい

### 解決策: 計画の明示化

Planモード活用:
```
人間: 「機能Xを実装してください。まず計画を立ててください」
   ↓
AI: （計画を立てる）
   ↓ (1分後)
AI: 「実装計画:
    1. ...
    2. ...
    この計画で進めてよろしいですか？」
   ↓
人間: 「2は不要です。1のみ実装してください」
   ↓
AI: 「了解しました」
   ↓ (10分後)
AI: 「完成しました！」
   ↓
人間: 「レビュー...OK！」
```

**メリット**:
- 1分後にAIの頭の中が見える
- 早期に軌道修正できる
- 手戻りがない

## 早期軌道修正による速度向上

### 数値で見る効果

#### ケース1: Planモードなし

```
要件定義: 5分
実装（間違った方向）: 30分
レビュー: 5分
修正指示: 2分
再実装: 20分
再レビュー: 5分
再修正指示: 2分
再々実装: 10分
最終レビュー: 5分
---------------------------------
合計: 84分
```

#### ケース2: Planモードあり

```
要件定義: 5分
計画立案: 1分
計画レビュー: 2分
修正指示: 1分
実装（正しい方向）: 25分
レビュー: 5分
---------------------------------
合計: 39分
```

**効果**: 84分 → 39分（**54%削減**）

### なぜ速くなるのか

1. **手戻りの削減**: 間違った方向に30分かけることがない
2. **レビューサイクルの短縮**: 1回のレビューで完了
3. **心理的負担の軽減**: 「違う方向に進んでいないか」という不安がない
4. **集中力の維持**: 長時間の手戻り作業でモチベーションが下がらない

## 実践例

### 例1: ユーザー管理機能の実装

#### Planモードなし（84分）

```
人間: 「ユーザー管理機能を実装してください」
AI: 「了解しました」
   ↓ (30分後)
AI: 「完成しました！以下を実装しました:
    - ユーザー作成
    - ユーザー一覧
    - ユーザー更新
    - ユーザー削除
    - ユーザー検索
    - ユーザーエクスポート（CSV/JSON）
    - メール通知
    - プロフィール画像アップロード」

人間: 「検索、エクスポート、メール通知、画像アップロードは不要です」
AI: 「了解しました。削除します」
   ↓ (20分後)
AI: 「修正完了しました！」

【結果】: 84分
```

#### Planモードあり（39分）

```
人間: 「ユーザー管理機能を実装してください。まず計画を立ててください」
AI: 「実装計画:
    1. ユーザー作成
    2. ユーザー一覧
    3. ユーザー更新
    4. ユーザー削除
    5. ユーザー検索
    6. ユーザーエクスポート（CSV/JSON）
    7. メール通知
    8. プロフィール画像アップロード

    この計画で進めてよろしいですか？」

人間: 「1-4のみ実装してください。5-8は不要です」
AI: 「了解しました。1-4のみ実装します」
   ↓ (25分後)
AI: 「完成しました！」

【結果】: 39分
```

### 例2: 複雑なビジネスロジックの実装

#### Planモードなし（120分）

```
人間: 「注文処理機能を実装してください」
AI: 「了解しました」
   ↓ (45分後)
AI: 「完成しました！」

人間: 「レビュー...在庫引き当てのタイミングが違う。トランザクション境界も間違っている」
AI: 「修正します」
   ↓ (30分後)
AI: 「修正完了しました！」

人間: 「レビュー...まだロールバック戦略が不適切です」
AI: 「修正します」
   ↓ (20分後)
AI: 「修正完了しました！」

【結果】: 120分
```

#### Planモードあり（50分）

```
人間: 「注文処理機能を実装してください。まず計画を立ててください」
AI: 「実装計画:

    ビジネスロジックフロー:
    1. 在庫チェック（ロック取得）
    2. 注文レコード作成（status=PENDING）
    3. 在庫引き当て
    4. 支払い処理
    5. 注文ステータス更新（status=CONFIRMED）

    トランザクション境界:
    - メソッド全体を@Transactionalで囲む

    この計画で進めてよろしいですか？」

人間: 「在庫チェックはロックなしで、引き当て時に楽観的ロックを使ってください」
AI: 「了解しました。修正します」
   ↓ (40分後)
AI: 「完成しました！」

【結果】: 50分
```

## ベストプラクティス

### 1. 大きな作業は必ずPlanモードを使う

**基準**:
- 実装時間が30分以上見込まれる
- 複数のファイルを変更する
- ビジネスロジックが複雑
- 不明確な要件がある

### 2. カスタムコマンドをチームで標準化

**推奨カスタムコマンド**:
- `/plan` - 実装計画
- `/implement` - 実装実行
- `/verify` - 完成度検証
- `/refactor` - リファクタリング
- `/review` - コードレビュー

### 3. 計画レビューは短時間で

**目標**:
- 計画レビュー: 1-3分以内
- 修正指示: 1分以内
- 承認判断: 即座

**コツ**:
- 「実装するもの」「実装しないもの」を明確に
- ファイルリストを確認
- 所要時間見積もりを確認

### 4. 計画と実装のズレを許容しない

実装中に計画から逸脱した場合:
```
AI: 「実装中ですが、計画にない機能Xが必要だと気づきました。
    実装してよろしいですか？」
```

**対応**:
- ✅ 「はい」または「いいえ」を明確に回答
- ❌ 無視して実装を続けさせない

### 5. 完成度検証を必ず実行

実装完了後:
```
人間: 「完成度を0-100点で評価してください」
AI: 「60点です。受入条件3つ目が未実装です」
人間: 「では続けて実装してください」
```

**100点になるまで繰り返す**。

## Planモードとカスタムコマンドの組み合わせ

### フルワークフロー

```
【STEP 1: 計画】
/plan ユーザー管理機能を実装

AI: 「実装計画: ...」
人間: 「OK」

【STEP 2: 実装】
/implement #123

AI: 「実装完了しました」

【STEP 3: 検証】
/verify

AI: 「80点です。JavaDocが不足しています」

【STEP 4: リファクタリング】
/refactor

AI: 「JavaDoc追加しました」

【STEP 5: 最終検証】
/verify

AI: 「100点です！」

【STEP 6: コミット】
git add . && git commit -m "feat: ユーザー管理機能を実装 (#123)"
```

### 所要時間

- 従来（Planモードなし）: 2時間
- 改善後（Planモード + カスタムコマンド）: 45分

**効果**: **62.5%削減**

## まとめ

### Planモードとカスタムコマンドの本質

AIは予期しない方向に進むことが多い。

**Planモード**と**カスタムコマンド**は、AIの思考を早期に言語化し、人間が軌道修正する仕組み。

### 主要なメリット

1. **早期軌道修正**: 実装前に方向性を確認
2. **手戻り削減**: 間違った方向に進まない
3. **速度向上**: 50-60%の時間削減
4. **品質向上**: 標準化されたチェック項目
5. **心理的安心**: 「違う方向に進んでいないか」という不安がない

### 3つのAI問題への対応

- **暴走（Scope Creep）** → 計画で「実装しないもの」を明確化
- **手抜き（Reward Hacking）** → `/verify`で完成度検証
- **忘れっぽさ（Context Limitations）** → カスタムコマンドで手順を永続化

### 実践のコツ

1. **30分以上の作業は必ずPlanモード**
2. **計画レビューは1-3分以内で判断**
3. **カスタムコマンドをチームで標準化**
4. **完成度検証は100点まで繰り返す**

Planモードとカスタムコマンドは、AI駆動開発を成功させるための必須ツール。早期軌道修正により、開発速度と品質の両方を向上させる。

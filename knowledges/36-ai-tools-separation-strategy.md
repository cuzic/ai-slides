# AI駆動開発におけるツール分離戦略：要件定義と実装の分離

## 概要

AI駆動開発において、**コンテキストの品質**は成果物の品質を直接左右します。特に重要な原則は、**質の低い内容をコンテキストに混ぜない**ことです。この目的を達成するため、初期の要件定義やユーザーストーリー作成には**Claude Code ではなく、Claude Web や Gemini などの対話型AIを使用**し、精緻化された要件を元に実装フェーズで Claude Code を使用する戦略が推奨されます。本ドキュメントでは、この「ツール分離戦略」の理論的根拠、実践的なワークフロー、ベストプラクティスをまとめます。

## なぜツールを分離するのか：理論的根拠

### 1. コンテキスト汚染の防止

**問題**：

前のドキュメント（`35-ai-context-contamination-quality-degradation.md`）で詳述したように、LLMは以下の特性を持ちます：

- **すべてのコンテキストを等しく扱う**：人間のように重要度をフィルタリングできない
- **汚染が累積する**：初期の誤りや曖昧さが後続の出力に影響し続ける
- **訂正が困難**：訂正しても元の誤りがコンテキストに残存

**要件定義フェーズの特性**：

- **探索的**：試行錯誤、アイデアの出し直し、方向転換が頻繁
- **曖昧さが多い**：初期段階では要件が不明確
- **繰り返し訂正**：ステークホルダーとの議論で要件が変わる

**結論**：

> 「要件定義の試行錯誤プロセスをそのまま実装フェーズのコンテキストに持ち込むと、**コンテキスト汚染により実装品質が低下する**」

### 2. 「精錬されたコンテキスト」の原則

**Spec-Driven Developmentの核心的洞察**：

> 「AIエージェントが成功するか失敗するかを決定する主なものは、**与えられたコンテキストの品質**である。仕様は『精錬されたコンテキスト』であり、LLMが圧倒されることなく効果的であるために**ちょうど十分な情報**を提供する」

**精錬プロセスの重要性**：

1. **生のアイデア**（曖昧、冗長、矛盾を含む可能性）
2. **探索と議論**（試行錯誤、訂正、方向転換）
3. **精錬された仕様**（明確、構造化、検証済み）← **これだけを実装に使う**
4. **実装**（精錬された仕様に基づく）

**ツール分離の目的**：

- **フェーズ1-2**（探索・精錬）：Claude Web / Gemini を使用
- **フェーズ3-4**（仕様確定・実装）：Claude Code を使用
- これにより、**汚染されたコンテキストを実装フェーズに持ち込まない**

### 3. コンテキストウィンドウサイズのパラドックス

**研究知見**：

> 「大規模言語モデルのコンテキストウィンドウは増加しているが、**より大きなコンテキストをLLMに提供すると実際には品質が低下する**」

**示唆**：

- 単にすべての情報を詰め込めばいいわけではない
- **精選された高品質なコンテキスト**が重要
- 要件定義の全プロセス履歴 < 精錬された最終仕様

### 4. フェーズごとの最適ツール選択

**Claude Web の強み**（要件定義に最適）：

- **速い反復**：30秒で応答（Claude Code は2-4倍遅い）
- **探索に最適**：ブレインストーミング、アイデア出し
- **柔軟な対話**：ドキュメント参照、GitHub リポジトリ参照
- **セットアップ不要**：すぐに開始できる

**Claude Code の強み**（実装に最適）：

- **深度**：より徹底的な分析
- **コンテキスト管理**：CLAUDE.md による永続的プロジェクトメモリ
- **大規模ファイル更新**：他のAIエージェントが苦戦する大規模ファイルの更新に成功
- **低レベルアクセス**：意図的に低レベルで非主張的、柔軟、カスタマイズ可能、スクリプト可能

**トレードオフの理解**：

> 「Claude Code は同じリクエストに**2-4倍の時間**がかかる。Web で30秒の編集が Code では2分かかる可能性があるが、**より多くの作業を行っている** - より多くのコンテキストをチェックし、より多くの可能性を考慮し、より徹底的である」

**使い分けの原則**：

- **速い反復が必要**（探索、要件定義）→ Claude Web
- **深度が必要**（実装、複雑なロジック）→ Claude Code

## ツール分離戦略の具体的ワークフロー

### フェーズ1：探索と要件収集（Claude Web / Gemini 使用）

#### 目的

- ビジネス要件の理解
- ステークホルダーとの対話
- アイデアのブレインストーミング
- 要件の初期ドラフト作成

#### 使用ツール

**Claude Web を推奨する理由**：

- 速い反復（30秒応答）
- Google Docs や GitHub リポジトリの参照が容易
- セットアップ不要で即座に開始

**Gemini を選択肢に含める理由**：

- Google エコシステムとの統合
- マルチモーダル（画像、動画も扱える）
- 異なる「視点」を得られる（複数AIの活用）

#### 具体的アクティビティ

1. **ビジネス目標の明確化**
   ```
   プロンプト例（Claude Web）:
   「以下のビジネス課題について、解決すべき本質的な問題を5つの視点から分析してください：
   [課題の説明]

   視点：
   1. ユーザーペインポイント
   2. ビジネス価値
   3. 技術的実現可能性
   4. リスクと制約
   5. 成功指標」
   ```

2. **ユーザーストーリーの生成**
   ```
   プロンプト例（Claude Web）:
   「以下の機能について、INVEST原則（Independent, Negotiable, Valuable,
   Estimable, Small, Testable）に基づいたユーザーストーリーを作成してください：
   [機能の説明]

   各ストーリーには以下を含めてください：
   - As a [ユーザータイプ]
   - I want [機能]
   - So that [価値/目的]
   - 受け入れ基準（Given-When-Then形式）」
   ```

3. **要件の反復的精緻化**
   - 初期ドラフト生成
   - ステークホルダーレビュー
   - フィードバック反映
   - **この過程で多くの訂正・方向転換が発生** ← これをClaudeCodeに持ち込まない

#### アウトプット

- **精錬されたユーザーストーリー集**
- **明確な受け入れ基準**
- **技術的制約の文書化**
- **成功指標の定義**

**重要**：このフェーズでの「会話履歴」は次のフェーズに持ち込まない

### フェーズ2：仕様の構造化と検証（Claude Web / Gemini 使用）

#### 目的

- 要件を構造化された仕様に変換
- 技術的詳細の追加
- 仕様の検証とレビュー
- **実装に十分な品質に精錬**

#### Spec-Driven Development アプローチ

**4フェーズプロセス**：

1. **Specify（仕様化）**
   - 高レベルの機能の目的と要件の記述
   - AIが詳細で構造化された仕様に拡張
   - **チェックポイント1**：仕様の妥当性確認

2. **Plan（計画）**
   - 仕様を実行可能なタスクに分解
   - アーキテクチャとアプローチの決定
   - **チェックポイント2**：計画の妥当性確認

3. **検証と精緻化**
   - SME（専門家）レビュー
   - 既存ドキュメント・基準との照合
   - ステークホルダーとのビジネス整合性確認
   - 過去のプロジェクト成果との検証

4. **最終仕様の確定**
   - 明確で曖昧さのない仕様
   - 実装に必要な技術詳細
   - テスト基準の明示

#### プロンプト例

```
プロンプト（Claude Web）:
「以下のユーザーストーリーを、実装可能な技術仕様に変換してください：

[ユーザーストーリー]

以下の観点で詳細化してください：
1. 機能の詳細な動作フロー
2. データモデル（必要なエンティティと関係）
3. API設計（エンドポイント、リクエスト/レスポンス形式）
4. UIコンポーネント構造
5. エッジケースの処理
6. エラーハンドリング戦略
7. パフォーマンス要件
8. セキュリティ考慮事項

出力形式：Markdown形式の構造化ドキュメント」
```

#### 検証チェックポイント

**チェックリスト**：

- [ ] 技術的正確性の確認（SMEレビュー）
- [ ] 既存の基準・ドキュメントとの整合性
- [ ] ステークホルダーとのビジネス整合性
- [ ] 実装可能性の評価
- [ ] テスト可能性の確認
- [ ] 曖昧さの除去

#### アウトプット

- **精錬された技術仕様書**（Markdown形式）
- **明確なタスク分解**
- **アーキテクチャ決定記録（ADR）**（必要に応じて）
- **テスト基準**

**重要**：この仕様が「精錬されたコンテキスト」として次のフェーズで使用される

### フェーズ3：実装準備とコンテキスト設定（Claude Code）

#### 目的

- **クリーンな実装コンテキストの構築**
- CLAUDE.md による永続的メモリ設定
- プロジェクト構造の確立

#### 新しいセッションで開始

**重要な原則**：

> 「フェーズ1-2の会話履歴は持ち込まない。精錬された仕様のみを新しいセッションに投入する」

**手順**：

1. **新しいClaude Codeセッション開始**
   ```bash
   # 新規プロジェクトで開始（既存の会話履歴なし）
   claude
   ```

2. **CLAUDE.mdの作成**
   ```markdown
   # プロジェクト概要
   [プロジェクトの簡潔な説明]

   # Tech Stack
   - Language: TypeScript
   - Framework: Next.js 14
   - Database: PostgreSQL
   - ORM: Prisma
   - Testing: Jest, React Testing Library

   # Architecture Patterns
   - クリーンアーキテクチャ
   - レイヤード構造
   - 依存性注入

   # Coding Standards
   - ESLint設定に従う
   - 関数型プログラミング優先
   - すべてのパブリック関数にJSDoc
   - テストカバレッジ80%以上

   # Project Structure
   - `src/components/`: 再利用可能なUIコンポーネント
   - `src/lib/`: コアビジネスロジック
   - `src/pages/`: Next.jsページ
   - `src/api/`: APIルート
   - `tests/`: テストファイル
   ```

3. **精錬された仕様の追加**

   フェーズ2で作成した仕様を、プロジェクトの`docs/specs/`ディレクトリに配置：

   ```
   docs/
   ├── specs/
   │   ├── feature-a-spec.md
   │   ├── feature-b-spec.md
   │   └── api-design.md
   ├── adr/
   │   └── 001-architecture-decision.md
   └── README.md
   ```

4. **CLAUDE.mdで仕様を参照**
   ```markdown
   # Specifications
   実装の詳細は以下のドキュメントを参照：
   - 機能A: `docs/specs/feature-a-spec.md`
   - 機能B: `docs/specs/feature-b-spec.md`
   - API設計: `docs/specs/api-design.md`

   実装時は必ず該当する仕様ドキュメントを確認してください。
   ```

#### コンテキスト品質の確保

**確認ポイント**：

- [ ] 探索フェーズの試行錯誤はコンテキストに含まれていない
- [ ] CLAUDE.mdは簡潔（2ページ以内）
- [ ] 仕様は明確で曖昧さがない
- [ ] プロジェクト構造が明確
- [ ] コーディング基準が明示されている

### フェーズ4：実装（Claude Code使用）

#### Plan-Then-Execute ワークフロー

**ステップ1：計画フェーズ**

```
プロンプト（Claude Code）:
「docs/specs/feature-a-spec.md を読んで、実装計画を立ててください。
まだコードは書かないでください。

以下を含む計画を作成してください：
1. 実装する必要があるファイルのリスト
2. 各ファイルの責務
3. 実装順序（依存関係を考慮）
4. テスト戦略
5. 潜在的な課題とその対処法」
```

**チェックポイント**：計画のレビューと承認

**ステップ2：実装フェーズ**

```
プロンプト（Claude Code）:
「承認された計画に基づいて、機能Aを実装してください。

要件：
- docs/specs/feature-a-spec.md の仕様に厳密に従う
- CLAUDE.md のコーディング基準を遵守
- 各ステップで小さな差分を作成
- 実装後、必ずテストを作成
- 実装完了後、レビュー用のサマリーを提供」
```

**小さな差分の原則**：

> 「Plan → 小さな差分 → テスト → レビュー、プレッシャーがあってもステップをスキップしない」

#### サブエージェントの活用

**推奨**：

> 「サブエージェントの強力な使用を検討、特に複雑な問題に対して - Claudeにサブエージェントを使用して詳細を検証したり、特定の質問を調査したりするよう指示することは、特に会話やタスクの早い段階で、コンテキストの可用性を保持する傾向がある」

**使用例**：

```
プロンプト（Claude Code）:
「実装を開始する前に、サブエージェントを使って以下を調査してください：
1. 既存のコードベースで類似の実装パターンを探す
2. 使用するライブラリのベストプラクティスを確認
3. エッジケースの処理方法を検討」
```

#### コンテキストの管理

**頻繁な `/clear` 使用**：

- タスク完了ごとに `/clear`
- タスクスイッチ前に `/clear`
- 長い会話（5-10ターン）で `/clear`

**CLAUDE.mdによる永続性**：

- `/clear` しても CLAUDE.md の内容は保持される
- プロジェクトの重要な決定を CLAUDE.md に追記
- セッション間で一貫性を維持

### フェーズ5：検証と反復（Claude Code使用）

#### テストと品質確認

```
プロンプト（Claude Code）:
「実装した機能Aについて、以下を実行してください：
1. すべてのテストが合格することを確認
2. 仕様との整合性を検証
3. エッジケースのカバレッジを確認
4. コード品質チェック（linter、型チェック）
5. 問題があれば修正計画を提案」
```

#### レビューとフィードバック

**チェックポイント**：

- [ ] 仕様の要件をすべて満たしている
- [ ] テストカバレッジが基準を満たす
- [ ] コーディング基準に準拠
- [ ] エラーハンドリングが適切
- [ ] ドキュメントが更新されている

## 多段階AI活用の高度な戦略

### 戦略1：複数AIツールの並行使用

#### 目的

異なるAIの「視点」を得て、より包括的な要件定義を実現

#### アプローチ

**ステップ1：並行探索**

同じ要件について、複数のAIに問い合わせる：

- **Claude Web**：構造化された分析、明確な論理
- **Gemini**：創造的なアイデア、マルチモーダル分析
- **ChatGPT**（オプション）：異なる視点

**ステップ2：統合と精緻化**

複数のAIからの出力を人間が統合：

- 共通する提案 → 高信頼度
- 相違する提案 → さらなる検討が必要
- ユニークな洞察 → 価値ある追加

**ステップ3：最終仕様の作成**

統合された洞察を基に、Claude Web で最終仕様を作成

#### メリット

- **バイアスの削減**：単一AIの偏りを回避
- **包括性の向上**：複数の視点からの分析
- **品質の向上**：相互検証による精度向上

### 戦略2：段階的コンテキスト精錬

#### プロセス

```
生のビジネス要求
    ↓ [Claude Web - 探索]
初期要件ドラフト（曖昧さあり）
    ↓ [Claude Web - 精緻化]
構造化された要件
    ↓ [SMEレビュー + Claude Web]
技術仕様（精錬済み）
    ↓ [新規セッション - Claude Code]
実装計画
    ↓ [Claude Code - 実装]
高品質コード
```

**各ステップでの品質ゲート**：

1. **探索後**：要件が明確か？曖昧さは除去されたか？
2. **精緻化後**：技術的詳細は十分か？実装可能か？
3. **仕様確定後**：すべてのステークホルダーが承認したか？
4. **計画後**：実装アプローチは適切か？
5. **実装後**：仕様を満たしているか？

#### 各ゲートでの決定

- **合格**：次のステップへ
- **不合格**：前のステップに戻って改善
- **重要な変更**：新しいセッションで再開

### 戦略3：Connected Pipeline アプローチ

#### 概念

> 「組織は、スタンドアロンAIツール（発見とAI要件収集に使用）と統合AIツール（構造と実行に使用）の間に**接続されたパイプライン**を構築できる - これは統合とスタンドアロンAIツールを統合する最も効果的な方法の1つである」

#### 実装

**ツールチェーン**：

1. **発見フェーズ**（スタンドアロンツール）
   - 会議記録ツール：ステークホルダー会話の取得
   - ドキュメントAIツール：主要要件の抽出
   - ユーザーフィードバック分析：SNS、レビュー、調査の継続的分析

2. **統合フェーズ**（ミドルウェア）
   - 中央ミドルウェア：データを構造化形式に統合
   - 検証と正規化
   - 仕様テンプレートへの変換

3. **実装フェーズ**（統合ツール）
   - JIRA / Azure DevOps へプッシュ
   - Claude Code で実装
   - CI/CD パイプラインと統合

#### メリット

- **一貫性**：すべてのツールが同じ構造化データを共有
- **追跡可能性**：要件から実装までの完全なトレーサビリティ
- **効率性**：手動転記の削減

## ツール選択のチートシート

### Claude Web を使用すべき場合

✅ **適している**：

- 要件の探索とブレインストーミング
- ユーザーストーリーの作成
- 仕様の初期ドラフト
- ステークホルダーとの議論内容の整理
- ドキュメントレビューとフィードバック統合
- アーキテクチャの選択肢比較
- 技術調査と学習
- クイックプロトタイプのアイデア検証

❌ **適していない**：

- 実際のコード実装
- 大規模ファイルの更新
- 複雑なリファクタリング
- マルチファイルの一貫した変更

### Claude Code を使用すべき場合

✅ **適している**：

- 精錬された仕様に基づく実装
- 大規模ファイルの更新
- 複雑なリファクタリング
- テストの作成と実行
- コードレビューとデバッグ
- プロジェクト全体の一貫した変更
- 既存コードベースとの統合
- 長期プロジェクトでの継続的開発

❌ **適していない**：

- 要件が不明確な探索的タスク
- 速い反復が必要なブレインストーミング
- 頻繁な方向転換が予想されるタスク

### Gemini を使用すべき場合

✅ **適している**：

- マルチモーダル入力（画像、動画）の分析
- Googleドキュメント・スプレッドシートとの統合
- 異なる視点の獲得（Claude との並行使用）
- UIデザインのモックアップ分析
- ユーザーフィードバック（スクリーンショット含む）の分析

### 使い分けの決定フロー

```
タスクの性質は？
    │
    ├─ 探索・要件定義・アイデア出し
    │   → 速い反復が必要？
    │       └─ YES → Claude Web または Gemini
    │
    ├─ 仕様化・構造化
    │   → 既に方向性は決まっている？
    │       └─ YES → Claude Web で精錬
    │       └─ NO → もっと探索（Claude Web / Gemini）
    │
    └─ 実装・コーディング
        → 仕様は明確で検証済み？
            └─ YES → Claude Code（新規セッション）
            └─ NO → フェーズ2に戻る（仕様精錬）
```

## 実践例：ユーザー管理機能の開発

### シナリオ

「新しいSaaSアプリケーションにユーザー管理機能を追加したい」

### フェーズ1：探索（Claude Web）

**プロンプト**：
```
「SaaSアプリケーションのユーザー管理機能について、以下を分析してください：

1. 一般的なユーザー管理機能の要件
2. セキュリティ考慮事項
3. ユーザーロールとパーミッション設計
4. GDPR / プライバシー要件
5. 実装の複雑度とリスク

背景：
- B2B SaaS
- チーム単位での利用
- エンタープライズ顧客を想定」
```

**アウトプット**（簡略版）：
```markdown
# ユーザー管理機能要件（初期分析）

## 主要機能
1. ユーザー登録・招待
2. 認証（メール/パスワード、SSO）
3. ロールベースアクセス制御（RBAC）
4. プロフィール管理
5. チーム管理

## セキュリティ要件
- パスワード強度要件
- 2FA サポート
- セッション管理
- 監査ログ

[以下、詳細...]
```

**反復**：ステークホルダーと議論し、何度も修正（この履歴は Claude Code に持ち込まない）

### フェーズ2：仕様化（Claude Web）

**プロンプト**：
```
「以下の承認された要件を、実装可能な技術仕様に変換してください：

[フェーズ1で精錬された要件]

以下の形式で出力：
1. データモデル（ER図をMermaid形式で）
2. API仕様（OpenAPI形式）
3. 認証フロー（シーケンス図）
4. 画面遷移（状態図）
5. エラーハンドリング戦略
6. テスト基準」
```

**アウトプット**：

`docs/specs/user-management-spec.md` という完全な技術仕様

**検証**：

- [ ] SME（セキュリティエンジニア）レビュー完了
- [ ] データモデルが正規化されている
- [ ] APIが RESTful原則に準拠
- [ ] セキュリティベストプラクティスを満たす
- [ ] すべてのステークホルダーが承認

### フェーズ3：実装準備（Claude Code - 新規セッション）

**CLAUDE.md の設定**：

```markdown
# User Management Feature

## Tech Stack
- Backend: Node.js + Express
- Database: PostgreSQL
- ORM: Prisma
- Auth: Passport.js + JWT
- Validation: Zod

## Specifications
実装詳細: `docs/specs/user-management-spec.md`

## Architecture Patterns
- Clean Architecture
- Repository Pattern
- Dependency Injection

## Security Standards
- OWASP Top 10 準拠
- すべてのパスワードは bcrypt でハッシュ化
- JWTトークンは環境変数から秘密鍵を取得
- すべての入力を検証（Zod使用）

## Testing Standards
- 単体テスト：Jest
- 統合テスト：Supertest
- カバレッジ：80%以上
```

### フェーズ4：実装（Claude Code）

**ステップ1：計画**

```
プロンプト（Claude Code）:
「docs/specs/user-management-spec.md を読んで、実装計画を立ててください。
まだコードは書かないでください。」
```

**Claude Code の応答**（例）：
```markdown
# Implementation Plan

## Phase 1: Database & Models
- File: `prisma/schema.prisma`
- Define: User, Team, Role, Permission models
- Relations: User-Team (many-to-many), User-Role, Role-Permission

## Phase 2: Repository Layer
- File: `src/repositories/userRepository.ts`
- File: `src/repositories/teamRepository.ts`
- CRUD operations + business queries

## Phase 3: Service Layer
- File: `src/services/authService.ts`
- File: `src/services/userService.ts`
- Business logic + validation

[以下、詳細...]
```

**チェックポイント**：計画を承認

**ステップ2：実装（小さな差分）**

```
プロンプト（Claude Code）:
「承認しました。Phase 1 から開始してください。
Prisma スキーマを実装してください。」
```

**ステップ3：テスト**

```
プロンプト（Claude Code）:
「Phase 1 のテストを作成してください。
モデルの関係性とバリデーションをテストする必要があります。」
```

**ステップ4：レビューと次のフェーズ**

```
プロンプト（Claude Code）:
「Phase 1 が完了しました。コードレビュー用のサマリーを提供してください。
問題がなければ、Phase 2 に進みます。」
```

**定期的な `/clear` 使用**：

各フェーズ完了後に `/clear` を実行し、コンテキストをクリーンに保つ

### 成果

- **高品質な実装**：精錬された仕様に基づく
- **コンテキスト汚染なし**：探索フェーズの試行錯誤は含まれていない
- **トレーサビリティ**：要件 → 仕様 → 実装の明確な経路
- **保守性**：明確なドキュメントと構造化されたコード

## ベストプラクティス

### 1. 「精錬されたコンテキスト」の原則

✅ **推奨**：

- 仕様を別ドキュメント（Markdown）として作成
- 仕様を検証・承認してから実装フェーズへ
- 実装時は仕様ファイルを参照させる

❌ **非推奨**：

- 探索から実装まで同じ会話で継続
- 曖昧な要件のまま実装開始
- 会話履歴全体をコンテキストに含める

### 2. セッション分離の原則

✅ **推奨**：

- 探索フェーズと実装フェーズで別セッション
- 各フェーズの開始時にクリーンなコンテキスト
- CLAUDE.md で永続的メモリを管理

❌ **非推奨**：

- すべてを1つの長い会話で実行
- セッションをまたいで汚染されたコンテキストを持ち越す

### 3. 検証ゲートの原則

✅ **推奨**：

- 各フェーズの完了時に検証チェックポイント
- ステークホルダー承認を取得
- 品質基準を満たしてから次へ

❌ **非推奨**：

- 検証なしで次のフェーズへ進む
- ステークホルダー承認をスキップ
- 「後で修正」と先送り

### 4. ドキュメント駆動の原則

✅ **推奨**：

- すべての主要な決定をドキュメント化
- 仕様をバージョン管理
- ドキュメントをコードと同様に扱う

❌ **非推奨**：

- 口頭やチャットでの決定のみ
- ドキュメントを「後で」書く
- ドキュメントの更新を怠る

### 5. ツール選択の原則

✅ **推奨**：

- タスクの性質に応じて最適なツールを選択
- 速い反復が必要 → Claude Web / Gemini
- 深い実装が必要 → Claude Code
- 異なる視点が必要 → 複数AI並行使用

❌ **非推奨**：

- すべてのタスクを同じツールで実行
- ツールの強みを考慮しない選択

## トラブルシューティング

### 問題1：実装中に要件が不明確と判明

**症状**：

Claude Code が「仕様が不明確」「どちらのアプローチを取るべきか不明」と応答

**解決策**：

1. **実装を一時停止**
2. **Claude Web で新規セッション**を開始
3. **不明確な部分を探索・精錬**
4. **仕様を更新**（docs/specs/ 内のファイル）
5. **Claude Code に更新を通知**：「docs/specs/xxx.md を更新しました。最新の仕様を読んで実装を続けてください」

### 問題2：実装の方向性が変わった

**症状**：

実装中に、アーキテクチャやアプローチを大きく変更する必要が発覚

**解決策**：

1. **現在のセッションで `/clear` 実行**
2. **CLAUDE.md を更新**（新しいアプローチを反映）
3. **必要に応じて仕様も更新**
4. **新しいセッションまたは `/clear` 後に再開**：「新しいアプローチに基づいて実装を再開します」

### 問題3：Claude Code の応答が遅い

**症状**：

Claude Code が2分以上かかる、またはタイムアウト

**解決策**：

1. **タスクを小さく分割**：大きすぎるタスクを細分化
2. **CLAUDE.md を簡潔に**：不要な情報を削除
3. **サブエージェントを活用**：調査タスクをサブエージェントに委譲
4. **必要に応じて Claude Web で計画**を立て、小さなタスクに分解してから Claude Code で実装

### 問題4：複数の仕様が矛盾

**症状**：

異なる仕様ファイルで矛盾する要件

**解決策**：

1. **Claude Web で矛盾を分析**：すべての仕様を提示し、矛盾点を特定
2. **ステークホルダーと調整**
3. **正しい仕様に統一**
4. **Claude Code に更新を通知**

## まとめ：成功のための重要原則

### 核心的理解

1. **コンテキスト品質が成果物品質を決定する**
   - 探索の試行錯誤 ≠ 実装のコンテキスト
   - 精錬された仕様のみを実装に使用

2. **ツールには適材適所がある**
   - 速い反復（探索）→ Claude Web / Gemini
   - 深い実装 → Claude Code
   - 使い分けが品質と効率を向上

3. **段階的精錬が鍵**
   - 生のアイデア → 構造化された要件 → 検証済み仕様 → 実装
   - 各ステップで品質ゲート
   - 前のステップが完了してから次へ

4. **セッション分離が汚染を防ぐ**
   - 探索と実装で別セッション
   - `/clear` を頻繁に使用
   - CLAUDE.md で永続的メモリ

### 実践への適用

**最小限の実践**（すぐに始められる）：

1. 要件定義は Claude Web で（探索と精錬）
2. 精錬された仕様をMarkdownファイルに保存
3. 新しい Claude Code セッションで実装開始
4. 仕様ファイルを参照させる

**推奨される実践**（より高い品質）：

1. 要件定義は Claude Web / Gemini で（複数AI並行も）
2. 仕様化と検証（SMEレビュー、ステークホルダー承認）
3. CLAUDE.md を適切に設定
4. 新しい Claude Code セッションで計画→実装
5. 各フェーズ後に `/clear`
6. 継続的な検証とフィードバック

### 最終推奨事項

> 「AI駆動開発の成功は、適切なツールを適切なタイミングで使用し、**質の高いコンテキストを維持**することで達成される。探索フェーズの『汚れた』コンテキストを実装に持ち込まないことが、高品質な成果物への最短経路である」

**投資対効果**：

- **時間投資**：要件定義と仕様化に追加の時間
- **品質向上**：コンテキスト汚染回避により大幅な品質改善
- **保守性向上**：明確なドキュメントによる長期的メリット
- **リスク削減**：検証ゲートによる早期問題発見

**段階的導入**：

1. **Week 1**：要件定義と実装でツールを分ける（Claude Web → Claude Code）
2. **Week 2-3**：仕様をMarkdownファイルとして管理
3. **Week 4+**：検証ゲート、複数AI並行使用などの高度な戦略

## 参考文献・出典

### Spec-Driven Development

- GitHub Blog: "Spec-driven development with AI: Get started with a new open source toolkit"
- Red Hat Developer: "How spec-driven development improves AI coding quality"
- The New Stack: "Spec-Driven Development: The Key to Scalable AI Agents"
- Dave Patten (Medium): "Spec-Driven Development: Designing Before You Code (Again)"
- Martin Fowler: "Understanding Spec-Driven-Development: Kiro, spec-kit, and Tessl"

### Claude Web vs Claude Code

- Anthropic: "Claude Code Best Practices"
- Builder.io: "How I use Claude Code (+ my best tips)"
- Warpedvisions.org: "Claude Code Versus Web Different Tools Different Thinking"
- Sid Bharath: "Cooking with Claude Code: The Complete Guide"
- Skywork AI: "Claude Code 2.0 Best Practices for AI Coding: Developer Workflow 2025"

### AI Requirements Gathering

- AgileM: "Generate User Stories Using AI | 21 AI Prompts + 15 Tips"
- ClickUp: "How to Use AI for User Stories in Agile Development"
- Copilot4DevOps: "How to generate AI user stories like a pro using AI"
- Getgenerative AI: "Salesforce Requirements with AI: Epics, User Stories & Acceptance Criteria"
- V2 Solutions: "Best AI Tools for Requirements Management in 2025"

### AI-Driven Development Lifecycle

- AWS DevOps Blog: "AI-Driven Development Life Cycle: Reimagining Software Engineering"
- arXiv: "The AI-Native Software Development Lifecycle"
- arXiv: "Generative AI for Requirements Engineering: A Systematic Literature Review"
- Binoy Ayyagari (Medium): "From Agile to Adaptive Intent-Driven Development (AIDD)"

### Context Engineering

- Prompt Engineering Guide: "Context Engineering Guide"
- A B Vijay Kumar (Medium): "Context Engineering - Getting the best out of Agentic AI Systems"
- LangChain Blog: "Context Engineering for Agents"
- Shelly Palmer: "Context Engineering: A Framework for Enterprise AI Operations"

### 関連ドキュメント（本knowledges内）

- `33-ai-context-documentation-importance.md`: コンテキストとドキュメントの重要性
- `35-ai-context-contamination-quality-degradation.md`: コンテキスト汚染と品質低下
- `23-user-story-writing.md`: ユーザーストーリー作成
- `08-architecture-decision-records-adr.md`: アーキテクチャ決定記録

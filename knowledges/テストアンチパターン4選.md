# テストアンチパターン4選: AI駆動開発で特に注意すべきパターン

## 概要

AI駆動開発において、以下の4つのテストアンチパターンが頻繁に発生します。これらはAIが「テストを通す」ことを最優先するために生成されがちなコードパターンです。

1. **Silent Fallback** - エラーを隠蔽してデフォルト値で処理継続
2. **Test Hacking** - テストを通すためだけの不自然な実装
3. **Mock Abuse** - 過剰なモックでテストの意味喪失
4. **Shallow Testing** - 表面的なテストで深い問題を見逃す

---

## 1. Silent Fallback（サイレント・フォールバック）

### 定義

エラーが発生した際に、例外をスローせず、デフォルト値や代替値を返して処理を継続するアンチパターン。**Error Hiding（エラー隠蔽）**とも呼ばれます。

### なぜ問題なのか？

1. **デバッグ不可能**: ログにエラーが記録されず、Sentryなどのエラー監視ツールにも検知されない
2. **ランダムな品質劣化**: ユーザー体験がランダムに悪化するが、誰も気づかない
3. **データ整合性の破壊**: エラー後も処理が続行され、不正なデータがDBに保存される
4. **再起動では解決しない**: データ破損が既に発生しているため、再起動しても問題は解決しない

### 典型的なパターン

#### パターン1: ユーザーが見つからない時に "unknown" を返す

```java
// ❌ Silent Fallback
public String getUserName(String userId) {
    try {
        User user = userDao.findById(userId);
        return user.getName();
    } catch (Exception e) {
        return "unknown";  // エラーを隠蔽
    }
}
```

**問題点**:
- DB接続エラーでも「unknown」を返す
- 本当にユーザーが存在しないのか、システムエラーなのか区別できない
- すべてのユーザー名が「unknown」と表示される可能性

**正しい対処**:
```java
// ✅ Fail Fast
public String getUserName(String userId) {
    User user = userDao.findById(userId);
    if (user == null) {
        throw new UserNotFoundException("ユーザーが見つかりません: " + userId);
    }
    return user.getName();
}
```

---

#### パターン2: 計算エラー時に0を返す

```java
// ❌ Silent Fallback
public BigDecimal calculateTotal(List<Item> items) {
    try {
        return items.stream()
            .map(Item::getPrice)
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    } catch (Exception e) {
        return BigDecimal.ZERO;  // エラーを隠蔽
    }
}
```

**問題点**:
- NullPointerExceptionが発生しても合計0円として処理
- 請求書の金額が0円になる = 売上損失

**正しい対処**:
```java
// ✅ Fail Fast
public BigDecimal calculateTotal(List<Item> items) {
    if (items == null || items.isEmpty()) {
        throw new ValidationException("E0201", "商品リストが空です");
    }
    return items.stream()
        .map(item -> {
            if (item.getPrice() == null) {
                throw new DataException("E0301", "商品価格が設定されていません: " + item.getId());
            }
            return item.getPrice();
        })
        .reduce(BigDecimal.ZERO, BigDecimal::add);
}
```

---

#### パターン3: 設定ファイル読み込みエラー時にデフォルト値

```java
// ❌ Silent Fallback
public Configuration loadConfig() {
    try {
        return configLoader.load("config.yml");
    } catch (IOException e) {
        log.warn("設定ファイルが読み込めません。デフォルト設定を使用します");
        return Configuration.DEFAULT;  // エラーを隠蔽
    }
}
```

**問題点**:
- 本番環境で設定ファイルが存在しないのに起動してしまう
- 意図しないデフォルト設定で動作し続ける
- セキュリティ設定が無効になる可能性

**正しい対処**:
```java
// ✅ Fail Fast（設定ファイルは必須）
public Configuration loadConfig() throws ConfigurationException {
    try {
        return configLoader.load("config.yml");
    } catch (IOException e) {
        log.error("設定ファイルの読み込みに失敗しました", e);
        throw new ConfigurationException("E9001", "設定ファイルが読み込めません", e);
    }
}

// または、デフォルト設定が許容される場合は明示的に
public Configuration loadConfigWithDefault() {
    try {
        return configLoader.load("config.yml");
    } catch (IOException e) {
        log.info("設定ファイルが見つかりません。デフォルト設定を使用します: {}", e.getMessage());
        return Configuration.createDefaultConfig();  // 明示的なメソッド名
    }
}
```

---

### Fail Fast原則

**Fail Fast**: 予期しないエラーが発生したら、即座に処理を停止する。

#### ベストプラクティス

1. **エラーを握りつぶさない**: 必ず例外をスロー
2. **ログを必ず出力**: エラーが発生したことを記録
3. **データ整合性を優先**: 不正なデータで処理を続けない
4. **原因不明のエラーは特に慎重に**: 想定外のエラーは絶対に握りつぶさない

```java
// ✅ Fail Fast実装例
public void processPayment(Payment payment) {
    // 入力値検証
    if (payment == null) {
        throw new IllegalArgumentException("支払い情報がnullです");
    }

    // ビジネスロジック
    try {
        paymentService.execute(payment);
    } catch (InsufficientFundsException e) {
        // 想定内のエラー: ユーザーに通知
        log.warn("残高不足: ユーザーID={}, 金額={}", payment.getUserId(), payment.getAmount());
        throw e;  // 再スロー
    } catch (PaymentGatewayException e) {
        // 外部システムエラー: 管理者に通知
        log.error("決済ゲートウェイエラー", e);
        throw new SystemException("E9002", "決済処理に失敗しました", e);
    } catch (Exception e) {
        // 想定外のエラー: 絶対に握りつぶさない
        log.error("予期しないエラーが発生しました", e);
        throw new SystemException("E9999", "システムエラー", e);
    }
}
```

---

## 2. Test Hacking（テスト・ハッキング）

### 定義

テストを通すためだけに、不自然な実装やロジックを追加するアンチパターン。テストの本来の目的（品質保証）を無視し、「テストが通ること」自体が目的化してしまう。

### 典型的なパターン

#### パターン1: Line Hitter（ラインヒッター）

テストがコードを「通過」するだけで、実際の動作を検証していない。

```java
// ❌ Line Hitter
public int divide(int a, int b) {
    if (b == 0) {
        return 0;  // テストでエラーを回避するだけ
    }
    return a / b;
}

// テストコード
@Test
void testDivide() {
    assertEquals(5, calculator.divide(10, 2));  // 正常系のみ
    assertEquals(0, calculator.divide(10, 0));  // ゼロ除算を「成功」として扱う
}
```

**問題点**:
- コードカバレッジは100%
- しかし「0で割ると0になる」という数学的に不正な結果を許容
- 本来例外をスローすべき

**正しい対処**:
```java
// ✅ 正しい実装
public int divide(int a, int b) {
    if (b == 0) {
        throw new ArithmeticException("ゼロで除算できません");
    }
    return a / b;
}

// テストコード
@Test
void testDivide_success() {
    assertEquals(5, calculator.divide(10, 2));
}

@Test
void testDivide_byZero() {
    assertThrows(ArithmeticException.class, () -> {
        calculator.divide(10, 0);
    });
}
```

---

#### パターン2: Inspector（インスペクター）

100%カバレッジを達成するために、カプセル化を破壊してprivateフィールドにアクセス。

```java
// ❌ Inspector
@Test
void testUserCreation() throws Exception {
    User user = new User("John", "john@example.com");

    // Reflectionでprivateフィールドにアクセス
    Field idField = User.class.getDeclaredField("id");
    idField.setAccessible(true);
    UUID id = (UUID) idField.get(user);

    assertNotNull(id);  // 内部実装の詳細をテスト
}
```

**問題点**:
- カプセル化の破壊
- リファクタリング時にテストが壊れる
- 内部実装の変更に対して脆弱

**正しい対処**:
```java
// ✅ 公開APIのみテスト
@Test
void testUserCreation() {
    User user = new User("John", "john@example.com");

    assertEquals("John", user.getName());
    assertEquals("john@example.com", user.getEmail());
    // IDは外部に公開する必要がある場合のみgetIdでテスト
}
```

---

#### パターン3: Free Ride（フリーライド）

1つのテストメソッドで複数の機能をテスト。新しいアサーションを既存テストに「便乗」させる。

```java
// ❌ Free Ride
@Test
void testUserOperations() {
    // ユーザー作成
    User user = userService.create("John", "john@example.com");
    assertNotNull(user);

    // ユーザー検索（便乗）
    User found = userService.findById(user.getId());
    assertEquals("John", found.getName());

    // ユーザー更新（便乗）
    found.setName("Jane");
    userService.update(found);
    assertEquals("Jane", found.getName());

    // ユーザー削除（便乗）
    userService.delete(found.getId());
    assertNull(userService.findById(found.getId()));
}
```

**問題点**:
- どの機能が失敗したのか分かりにくい
- 前の処理が失敗すると後続のテストが実行されない
- テストの保守が困難

**正しい対処**:
```java
// ✅ 1テスト1機能
@Test
void testCreateUser() {
    User user = userService.create("John", "john@example.com");
    assertNotNull(user);
    assertEquals("John", user.getName());
}

@Test
void testFindUserById() {
    User user = userService.create("John", "john@example.com");
    User found = userService.findById(user.getId());
    assertEquals("John", found.getName());
}

@Test
void testUpdateUser() {
    User user = userService.create("John", "john@example.com");
    user.setName("Jane");
    userService.update(user);
    assertEquals("Jane", userService.findById(user.getId()).getName());
}

@Test
void testDeleteUser() {
    User user = userService.create("John", "john@example.com");
    userService.delete(user.getId());
    assertThrows(UserNotFoundException.class, () -> {
        userService.findById(user.getId());
    });
}
```

---

#### パターン4: Happy Path Only（ハッピーパスのみ）

正常系のテストしか書かない。

```java
// ❌ Happy Path Only
@Test
void testLogin() {
    User user = authService.login("user@example.com", "password123");
    assertNotNull(user);
}
```

**問題点**:
- 異常系がテストされていない
- 本番環境でエラーが発生して初めて問題に気づく

**正しい対処**:
```java
// ✅ 正常系 + 異常系
@Test
void testLogin_success() {
    User user = authService.login("user@example.com", "password123");
    assertNotNull(user);
    assertEquals("user@example.com", user.getEmail());
}

@Test
void testLogin_invalidEmail() {
    assertThrows(ValidationException.class, () -> {
        authService.login("invalid-email", "password123");
    });
}

@Test
void testLogin_wrongPassword() {
    assertThrows(AuthenticationException.class, () -> {
        authService.login("user@example.com", "wrong-password");
    });
}

@Test
void testLogin_userNotFound() {
    assertThrows(UserNotFoundException.class, () -> {
        authService.login("notexist@example.com", "password123");
    });
}

@Test
void testLogin_accountLocked() {
    assertThrows(AccountLockedException.class, () -> {
        authService.login("locked@example.com", "password123");
    });
}
```

---

## 3. Mock Abuse（モック濫用）

### 定義

**Mockery（モッカリー）**とも呼ばれる。テストに大量のモック、スタブ、フェイクが含まれ、実際のシステムではなく、モックから返されるデータをテストしている状態。

### なぜ問題なのか？

1. **偽りの安心感**: テストは通るが、実際のコードはテストされていない
2. **複雑性の増加**: モックの設定がテスト対象のコードより複雑になる
3. **実装詳細のテスト**: モックは実装の詳細と密結合し、リファクタリングで壊れやすい
4. **実際のバグを見逃す**: I/Oコードと外部サービスの統合部分のバグを検出できない

### 典型的なパターン

#### パターン1: 過剰なモック

```java
// ❌ Mock Abuse
@Test
void testCreateOrder() {
    // 大量のモック設定
    when(userRepository.findById(anyString())).thenReturn(mockUser);
    when(productRepository.findById(anyString())).thenReturn(mockProduct);
    when(inventoryService.checkStock(any())).thenReturn(true);
    when(priceCalculator.calculate(any())).thenReturn(BigDecimal.valueOf(1000));
    when(taxCalculator.calculate(any())).thenReturn(BigDecimal.valueOf(100));
    when(shippingService.calculateFee(any())).thenReturn(BigDecimal.valueOf(500));
    when(orderRepository.save(any())).thenReturn(mockOrder);
    when(emailService.sendConfirmation(any())).thenReturn(true);

    // 実際のテスト
    Order order = orderService.createOrder(userId, productId, quantity);

    // アサーション
    assertNotNull(order);

    // モックの呼び出し検証（実装詳細）
    verify(userRepository).findById(userId);
    verify(productRepository).findById(productId);
    verify(inventoryService).checkStock(any());
    verify(priceCalculator).calculate(any());
    verify(taxCalculator).calculate(any());
    verify(shippingService).calculateFee(any());
    verify(orderRepository).save(any());
    verify(emailService).sendConfirmation(any());
}
```

**問題点**:
- モックの設定がテストコードの大部分を占める
- 実装の詳細（メソッド呼び出しの順序など）をテストしている
- リファクタリングでテストが壊れる
- 実際の統合部分のバグを検出できない

**正しい対処**:
```java
// ✅ 統合テスト or モックを最小限に
@Test
void testCreateOrder() {
    // テストデータをDBに準備（H2などのテストDB使用）
    User user = testDataBuilder.createUser();
    Product product = testDataBuilder.createProduct(price: 1000);

    // 外部サービスのみモック（メール送信など）
    when(emailService.sendConfirmation(any())).thenReturn(true);

    // 実際のテスト
    Order order = orderService.createOrder(user.getId(), product.getId(), 2);

    // ビジネスロジックの結果を検証
    assertEquals(user.getId(), order.getUserId());
    assertEquals(product.getId(), order.getProductId());
    assertEquals(2, order.getQuantity());
    assertEquals(BigDecimal.valueOf(2200), order.getTotalAmount());  // 1000*2 + 消費税10%

    // DBに保存されているか確認
    Order saved = orderRepository.findById(order.getId());
    assertNotNull(saved);
}
```

---

#### パターン2: Tautological TDD（トートロジカルTDD）

モックを使いすぎて、テストが実装のコピーになってしまう。

```java
// ❌ Tautological TDD
@Test
void testCalculateDiscount() {
    // モックで実装を再現
    when(discountCalculator.getBaseDiscount()).thenReturn(0.1);
    when(discountCalculator.getMemberDiscount()).thenReturn(0.05);
    when(discountCalculator.getCampaignDiscount()).thenReturn(0.1);

    BigDecimal result = discountService.calculate(price);

    // 期待値も実装と同じ計算式
    BigDecimal expected = price.multiply(BigDecimal.valueOf(1 - 0.1 - 0.05 - 0.1));
    assertEquals(expected, result);
}
```

**問題点**:
- テストが実装のコピーペースト
- テストが何も検証していない（トートロジー）
- 実装のバグをテストも再現してしまう

**正しい対処**:
```java
// ✅ 具体的な値でビジネスロジックを検証
@Test
void testCalculateDiscount_noMember() {
    User user = testDataBuilder.createNonMember();
    BigDecimal price = BigDecimal.valueOf(10000);

    BigDecimal result = discountService.calculate(user, price);

    // ビジネスルールに基づく期待値
    assertEquals(BigDecimal.valueOf(10000), result);  // 割引なし
}

@Test
void testCalculateDiscount_member() {
    User user = testDataBuilder.createMember();
    BigDecimal price = BigDecimal.valueOf(10000);

    BigDecimal result = discountService.calculate(user, price);

    assertEquals(BigDecimal.valueOf(9500), result);  // 5%割引
}

@Test
void testCalculateDiscount_memberWithCampaign() {
    User user = testDataBuilder.createMember();
    Campaign campaign = testDataBuilder.createCampaign(discount: 0.1);
    BigDecimal price = BigDecimal.valueOf(10000);

    BigDecimal result = discountService.calculate(user, price, campaign);

    assertEquals(BigDecimal.valueOf(8550), result);  // 会員5% + キャンペーン10% = 15%割引
}
```

---

#### パターン3: Leaky Mocks（漏れるモック）

モックの設定がテストメソッド間で共有され、テストが互いに影響し合う。

```java
// ❌ Leaky Mocks
@Mock
private UserRepository userRepository;

@BeforeEach
void setUp() {
    // すべてのテストで同じモック設定
    when(userRepository.findById(anyString())).thenReturn(mockUser);
}

@Test
void testActiveUser() {
    User user = userService.getUser("user001");
    assertTrue(user.isActive());  // mockUserがactiveを前提
}

@Test
void testInactiveUser() {
    // 前のテストのモック設定が影響
    User user = userService.getUser("user002");
    assertFalse(user.isActive());  // テスト失敗！mockUserはactiveのまま
}
```

**問題点**:
- テストの実行順序で結果が変わる
- デバッグが困難
- テストの独立性が失われる

**正しい対処**:
```java
// ✅ 各テストで独立したセットアップ
@Test
void testActiveUser() {
    User activeUser = testDataBuilder.createActiveUser();
    when(userRepository.findById("user001")).thenReturn(activeUser);

    User user = userService.getUser("user001");
    assertTrue(user.isActive());
}

@Test
void testInactiveUser() {
    User inactiveUser = testDataBuilder.createInactiveUser();
    when(userRepository.findById("user002")).thenReturn(inactiveUser);

    User user = userService.getUser("user002");
    assertFalse(user.isActive());
}
```

---

### モックを使うべきタイミング

#### ✅ モックが適切なケース

1. **外部サービス**: メール送信、SMS、決済API
2. **時間依存**: 現在時刻、タイマー
3. **非決定的な処理**: ランダム値生成
4. **遅い処理**: ファイルI/O、ネットワーク（ただし統合テストでは実施）

```java
// ✅ 外部サービスはモック
@Test
void testUserRegistration() {
    when(emailService.sendWelcomeEmail(any())).thenReturn(true);
    when(clock.now()).thenReturn(LocalDateTime.of(2025, 1, 1, 0, 0));

    User user = userService.register("test@example.com", "password");

    assertEquals("test@example.com", user.getEmail());
    verify(emailService).sendWelcomeEmail(user.getEmail());
}
```

#### ❌ モックが不適切なケース

1. **自分のコード**: Service、Repository、Controllerなどの内部実装
2. **簡単なロジック**: 計算、文字列操作
3. **インメモリDB**: H2、Testcontainersで実際のDBを使う方が良い

---

## 4. Shallow Testing（表面的テスト）

### 定義

アプリケーションの表面的な動作のみをテストし、深い問題（ビジネスロジック、境界値、例外処理、統合部分）を見逃すアンチパターン。

### 典型的なパターン

#### パターン1: UIインタラクションのみテスト

```javascript
// ❌ Shallow Testing（React）
test('renders login button', () => {
  render(<LoginPage />);
  const button = screen.getByText('ログイン');
  expect(button).toBeInTheDocument();  // ボタンが存在するだけ
});

test('can type in email field', () => {
  render(<LoginPage />);
  const input = screen.getByLabelText('メールアドレス');
  fireEvent.change(input, { target: { value: 'test@example.com' } });
  expect(input.value).toBe('test@example.com');  // 入力できるだけ
});
```

**問題点**:
- UI要素が存在することしか確認していない
- 実際のビジネスロジック（ログイン処理）はテストされていない
- APIコール、認証、エラーハンドリングが未検証

**正しい対処**:
```javascript
// ✅ Deep Testing
test('successful login redirects to dashboard', async () => {
  const mockLogin = jest.fn().mockResolvedValue({ token: 'abc123' });
  render(<LoginPage onLogin={mockLogin} />);

  // ユーザー操作
  fireEvent.change(screen.getByLabelText('メールアドレス'), {
    target: { value: 'test@example.com' }
  });
  fireEvent.change(screen.getByLabelText('パスワード'), {
    target: { value: 'password123' }
  });
  fireEvent.click(screen.getByText('ログイン'));

  // ビジネスロジックの検証
  await waitFor(() => {
    expect(mockLogin).toHaveBeenCalledWith('test@example.com', 'password123');
    expect(window.location.pathname).toBe('/dashboard');
  });
});

test('failed login shows error message', async () => {
  const mockLogin = jest.fn().mockRejectedValue(new Error('認証失敗'));
  render(<LoginPage onLogin={mockLogin} />);

  fireEvent.change(screen.getByLabelText('メールアドレス'), {
    target: { value: 'test@example.com' }
  });
  fireEvent.change(screen.getByLabelText('パスワード'), {
    target: { value: 'wrong' }
  });
  fireEvent.click(screen.getByText('ログイン'));

  await waitFor(() => {
    expect(screen.getByText('メールアドレスまたはパスワードが正しくありません')).toBeInTheDocument();
  });
});
```

---

#### パターン2: 境界値を無視

```java
// ❌ Shallow Testing
@Test
void testAgeValidation() {
    assertTrue(validator.isValidAge(25));  // 通常の値のみ
}
```

**問題点**:
- 境界値（0、負数、上限値など）をテストしていない
- 実際のエラーは境界値で発生しやすい

**正しい対処**:
```java
// ✅ Deep Testing（境界値テスト）
@Test
void testAgeValidation_valid() {
    assertTrue(validator.isValidAge(0));   // 最小値
    assertTrue(validator.isValidAge(1));   // 最小値+1
    assertTrue(validator.isValidAge(25));  // 通常値
    assertTrue(validator.isValidAge(150)); // 最大値
}

@Test
void testAgeValidation_invalid() {
    assertFalse(validator.isValidAge(-1));  // 最小値-1
    assertFalse(validator.isValidAge(151)); // 最大値+1
    assertFalse(validator.isValidAge(999)); // 異常値
}

@Test
void testAgeValidation_null() {
    assertThrows(IllegalArgumentException.class, () -> {
        validator.isValidAge(null);
    });
}
```

---

#### パターン3: ビジネスルールの未検証

```java
// ❌ Shallow Testing
@Test
void testCalculateShippingFee() {
    BigDecimal fee = shippingService.calculate(1000);
    assertNotNull(fee);  // nullでないことだけ確認
}
```

**問題点**:
- 実際の送料計算ロジックが正しいか検証していない
- ビジネスルール（重量、距離、割引など）が未テスト

**正しい対処**:
```java
// ✅ Deep Testing（ビジネスルール検証）
@Test
void testCalculateShippingFee_under1000yen() {
    BigDecimal fee = shippingService.calculate(weight: 500, distance: 10);
    assertEquals(BigDecimal.valueOf(500), fee);  // 500円固定
}

@Test
void testCalculateShippingFee_over1000yen() {
    BigDecimal fee = shippingService.calculate(weight: 1500, distance: 10);
    assertEquals(BigDecimal.valueOf(750), fee);  // 重量 * 0.5
}

@Test
void testCalculateShippingFee_longDistance() {
    BigDecimal fee = shippingService.calculate(weight: 500, distance: 100);
    assertEquals(BigDecimal.valueOf(1000), fee);  // 距離加算
}

@Test
void testCalculateShippingFee_freeShipping() {
    BigDecimal fee = shippingService.calculate(orderAmount: 10000, weight: 500);
    assertEquals(BigDecimal.ZERO, fee);  // 10000円以上は送料無料
}

@Test
void testCalculateShippingFee_hokkaido() {
    BigDecimal fee = shippingService.calculate(weight: 500, prefecture: "北海道");
    assertEquals(BigDecimal.valueOf(1500), fee);  // 北海道は別料金
}
```

---

#### パターン4: Ice Cream Cone（アイスクリームコーン）

テストピラミッドが逆転し、E2Eテストが多く、ユニットテストが少ない状態。

```
        /\
       /  \      ← E2Eテスト（多い）
      /    \
     /------\    ← 統合テスト（少ない）
    /--------\
   /          \  ← ユニットテスト（最も少ない）
  --------------
```

**問題点**:
- E2Eテストは遅く、脆弱で、デバッグが困難
- ユニットテストが少ないので問題の特定が難しい
- CI/CDが遅くなる

**正しい対処（テストピラミッド）**:
```
   /\
  /  \         ← E2Eテスト（少ない）
 /----\
/------\       ← 統合テスト（中程度）
/--------\
/----------\   ← ユニットテスト（最も多い）
--------------
```

**実装例**:
```java
// ✅ ユニットテスト（70%）
@Test
void testCalculateDiscount() {
    BigDecimal result = discountCalculator.calculate(10000, 0.1);
    assertEquals(BigDecimal.valueOf(9000), result);
}

// ✅ 統合テスト（20%）
@SpringBootTest
@Test
void testOrderCreation() {
    Order order = orderService.createOrder(userId, productId, quantity);
    assertNotNull(order.getId());
}

// ✅ E2Eテスト（10%）
@Test
void testFullCheckoutFlow() {
    // Seleniumなどで実際のブラウザ操作
    driver.get("/products");
    driver.findElement(By.id("add-to-cart")).click();
    driver.findElement(By.id("checkout")).click();
    // ... 省略 ...
}
```

---

### Shallow Testing vs Deep Testing

| 観点 | Shallow Testing | Deep Testing |
|------|----------------|--------------|
| **対象** | UIの存在確認のみ | ビジネスロジック全体 |
| **境界値** | 無視 | 必ずテスト |
| **異常系** | 無視 | 必ずテスト |
| **統合部分** | モックで回避 | 実際にテスト |
| **カバレッジ** | 表面的に高い | 本質的に高い |
| **バグ検出** | 低い | 高い |

---

## AIへのプロンプト対策

### 対策1: アンチパターンを明示的に禁止

```markdown
## テスト要件

以下のアンチパターンを禁止します:

### Silent Fallback禁止
- ❌ エラー時にnullやデフォルト値を返す
- ✅ 必ず例外をスローし、ログを出力

### Test Hacking禁止
- ❌ テストを通すためだけの不自然な実装
- ✅ ビジネスロジックに基づいた実装

### Mock Abuse禁止
- ❌ 自分のコードを過剰にモック
- ✅ 外部サービスのみモック、内部は実際のコードを使用

### Shallow Testing禁止
- ❌ 正常系のみテスト
- ✅ 境界値、異常系、統合部分も必ずテスト

[コードを生成してください]
```

---

### 対策2: テスト要件を具体的に指定

```markdown
## テスト要件

以下のすべてのケースをテストしてください:

### 1. 正常系
- 典型的な入力値での動作

### 2. 境界値
- 最小値、最小値-1、最小値+1
- 最大値、最大値-1、最大値+1
- 0、null、空文字列

### 3. 異常系
- 入力値不正
- データ不存在
- DB接続エラー
- タイムアウト
- 権限エラー

### 4. ビジネスルール
- 割引計算の正確性
- 送料計算の条件分岐
- 在庫引き当てロジック

[テストコードを生成してください]
```

---

### 対策3: コードレビュー用プロンプト

```markdown
以下のテストコードをレビューし、アンチパターンを指摘してください。

## チェックリスト

### Silent Fallback
- [ ] エラー時にnull/デフォルト値を返していないか
- [ ] すべての例外が適切に処理されているか

### Test Hacking
- [ ] Line Hitter（通過するだけ）になっていないか
- [ ] Inspector（private フィールドアクセス）していないか
- [ ] Free Ride（1テストで複数機能）になっていないか
- [ ] Happy Path Only（正常系のみ）になっていないか

### Mock Abuse
- [ ] 過剰なモックがないか
- [ ] 自分のコードをモックしていないか
- [ ] Tautological TDD（実装のコピー）になっていないか

### Shallow Testing
- [ ] 境界値をテストしているか
- [ ] 異常系をテストしているか
- [ ] ビジネスロジックを検証しているか
- [ ] 統合部分をテストしているか

## テストコード
[レビュー対象のテストコードを貼り付け]

問題点を具体的に指摘し、修正案を提示してください。
```

---

## CI/CD統合による検出

### 静的解析ツール

**1. Checkstyle: Silent Fallbackを検出**
```xml
<module name="EmptyCatchBlock"/>
<module name="IllegalCatch"/>
```

**2. Mutation Testing: Shallow Testingを検出**
```xml
<plugin>
    <groupId>org.pitest</groupId>
    <artifactId>pitest-maven</artifactId>
    <configuration>
        <mutationThreshold>80</mutationThreshold>
    </configuration>
</plugin>
```

Mutation Testingは、コードを意図的に変更（ミューテーション）して、テストが失敗するか確認します。テストが通り続ける場合、テストが不十分（Shallow Testing）であることを示します。

**3. Code Coverage: テスト不足を検出**
```xml
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <configuration>
        <rules>
            <rule>
                <element>BUNDLE</element>
                <limits>
                    <limit>
                        <counter>LINE</counter>
                        <value>COVEREDRATIO</value>
                        <minimum>0.80</minimum>
                    </limit>
                    <limit>
                        <counter>BRANCH</counter>
                        <value>COVEREDRATIO</value>
                        <minimum>0.75</minimum>
                    </limit>
                </limits>
            </rule>
        </rules>
    </configuration>
</plugin>
```

---

## まとめ

### 4つのアンチパターンの関係

```
Silent Fallback
    ↓
エラーが隠蔽される
    ↓
Test Hacking
    ↓
テストを通すための不自然な実装
    ↓
Mock Abuse
    ↓
実装の詳細をモックで隠蔽
    ↓
Shallow Testing
    ↓
表面的なテストのみで品質問題を見逃す
    ↓
本番環境でバグ発生
```

### 対策の3つの柱

1. **プロンプト設計**
   - アンチパターンを明示的に禁止
   - テスト要件を具体的に指定
   - ビジネスルールを明確化

2. **コードレビュー**
   - AIにレビューさせる
   - チェックリストで確認
   - 人間の最終確認

3. **CI/CD統合**
   - 静的解析（Checkstyle）
   - Mutation Testing（PIT）
   - Code Coverage（JaCoCo）
   - ビルド時の自動チェック

### 実践のポイント

✅ **Fail Fast**: エラーは即座に処理停止
✅ **テストはビジネスロジックを検証**: 実装の詳細ではなく
✅ **モックは最小限**: 外部サービスのみ
✅ **境界値・異常系は必須**: Happy Pathだけでは不十分
✅ **テストピラミッドを守る**: ユニットテスト70%、統合20%、E2E10%

### 参考リソース

- [Error Hiding - Wikipedia](https://en.wikipedia.org/wiki/Error_hiding)
- [Unit Testing Anti-Patterns - Yegor Bugayenko](https://www.yegor256.com/2018/12/11/unit-testing-anti-patterns.html)
- [Software Testing Anti-patterns - Codepipes](https://blog.codepipes.com/testing/software-testing-antipatterns.html)
- [Fail Fast Principle - Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/fail-fast-principle/)
- [Test Smells - xUnit Patterns](http://xunitpatterns.com/TestSmells.html)

---

**AI駆動開発では、これら4つのアンチパターンを意識的に避けることが品質の鍵！**

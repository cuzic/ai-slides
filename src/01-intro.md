---
marp: true
theme: default
paginate: true
---

<style>

  /* フォントサイズバリエーション */
  section[data-class~="font-large"] {
    font-size: 28px !important;
    line-height: 1.5 !important;
  }
  section[data-class~="font-large"] h2 {
    font-size: 42px !important;
  }

  section[data-class~="font-medium"] {
    font-size: 22px !important;
    line-height: 1.4 !important;
  }

  /* 大きめ（10行程度） */
  section[data-class~="font-small"] {
    font-size: 24px !important;
    line-height: 1.3 !important;
  }
  section[data-class~="font-small"] h2, section[data-class~="font-small"] h3 {
    font-size: 36px !important;
  }

  /* 中程度（12-14行） */
  section[data-class~="font-xsmall"] {
    font-size: 21px !important;
    line-height: 1.25 !important;
  }
  section[data-class~="font-xsmall"] h2, section[data-class~="font-xsmall"] h3 {
    font-size: 32px !important;
  }

  /* やや小さめ（15-17行） */
  section[data-class~="font-xxsmall"] {
    font-size: 18px !important;
    line-height: 1.2 !important;
  }
  section[data-class~="font-xxsmall"] h2, section[data-class~="font-xxsmall"] h3 {
    font-size: 28px !important;
  }

  /* コンパクト（18行以上） */
  section[data-class~="font-xxxsmall"] {
    font-size: 16px !important;
    line-height: 1.15 !important;
  }
  section[data-class~="font-xxxsmall"] h2, section[data-class~="font-xxxsmall"] h3 {
    font-size: 24px !important;
  }

  /* 2カラムレイアウト */
  .columns {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1.5rem;
    margin-top: 0.5em;
  }
  .columns ul {
    margin: 0;
  }

  /* 3カラムレイアウト */
  .columns-3 {
    display: grid;
    grid-template-columns: repeat(3, minmax(0, 1fr));
    gap: 1rem;
    margin-top: 0.5em;
  }
  .columns-3 ul {
    margin: 0;
    font-size: 0.85em;
  }

  /* コンパクトリスト */
  .compact-list li {
    margin-bottom: 0.2em;
    font-size: 0.95em;
  }

  /* ハイライトボックス */
  .highlight-box {
    background: #e8f0fe;
    border-left: 4px solid #1a73e8;
    padding: 1rem 1.5rem;
    margin: 1em 0;
    border-radius: 4px;
  }

  /* 警告ボックス */
  .warning-box {
    background: #fef7e0;
    border-left: 4px solid #f9ab00;
    padding: 1rem 1.5rem;
    margin: 1em 0;
    border-radius: 4px;
  }

  /* キーメッセージ */
  .key-message {
    font-size: 1.3em;
    font-weight: bold;
    color: #1a73e8;
    text-align: center;
    margin: 1.5em 0;
    padding: 1em;
    background: #f8f9fa;
    border-radius: 8px;
  }

  /* チェックリスト */
  .checklist ul {
    list-style: none;
    padding-left: 0;
  }
  .checklist li::before {
    content: "✓ ";
    color: #34a853;
    font-weight: bold;
  }

</style>


# AI駆動開発セミナー Day 1
## 入門編：AIとの正しい付き合い方

**対象者**: Python開発者（AI駆動開発は初心者）
**学習目標**: AI駆動開発の基本的なマインドセット、Claude Code活用法、プロジェクト初期化、AI特性理解、5-STEPワークフローの完全理解

---

## なぜAI駆動開発なのか

---
<!-- _class: font-xsmall -->

### 成功例① Harvard/BCG研究（2023年）

**研究概要**
- BCGコンサルタント758人を対象にGPT-4の効果を測定
- 対象者：学士以上、実務経験4年以内のジュニアコンサルタント
- 3グループに分割：①AI未使用、②GPT-4使用、③GPT-4＋プロンプト指導

**結果（AIの得意領域のタスク）**
- タスク完了数：12.2%増加
- 作業速度：25.1%高速化
- 成果物の品質：40%以上向上

**重要な発見：「凸凹フロンティア」**
- AIが苦手な領域のタスクでは、正解率が19ポイント低下
- AIの得意・不得意を見極めることが成功の鍵

---
<!-- _class: font-xsmall -->

### 成功例② 楽天のClaude Code活用事例（2025年）

**タスク内容**
- vLLM（オープンソースLLM推論ライブラリ、1,250万行）に対して
- 特定のActivation Vector抽出手法を実装

**驚異的な結果**
- Claude Codeが**7時間連続で自律作業**（人間は方向修正のみ）
- 実装精度：リファレンス手法と比較して**99.9%の数値精度**
- 「7時間、私はコードを1行も書かなかった」（機械学習エンジニア談）

**ビジネスインパクト**
- 機能リリース期間：24営業日 → 5日（**79%短縮**）
- 並列作業：5タスクを同時進行（4つをClaude Codeに委任）

---
<!-- _class: font-small -->

### 失敗例① Uplevel社調査（2024年）- バグ41%増加

**研究概要**
- **約800人**の開発者を対象（大規模エンジニアリングチーム）
- **テスト群 vs コントロール群**の比較研究
- 期間：導入前（2023年1-4月）と導入後（2024年1-4月）の3ヶ月間を比較
- 測定指標：サイクルタイム、PRスループット、バグ率、残業時間（Always On時間）

**衝撃的な結果**
- **バグ率：41%増加**（Copilot使用グループ）
- PRスループット：**有意な変化なし**（速くなっていない）
- PRサイクルタイム：**変化なし**
- バーンアウトリスク軽減：Copilotなし28%減 vs Copilotあり17%減

---
<!-- _class: font-small -->

### 失敗例① Uplevel社調査（続き）- 自己申告との乖離

**開発者の主観 vs 客観データ**
- GitHubの自社調査：「Copilotで生産性向上を実感」（主観）
- Uplevelの客観測定：「**生産性向上なし、バグ増加**」（客観）
- この乖離が問題の本質を示している

**原因の考察（Matt Hoffman, Uplevel PM）**
- 「AIはWeb上の**様々な品質のコード**で訓練されている」
- 「アクセス権を与えただけで、**適切な使い方の指導がなかった**」
- 品質の低いコードを学習したAIが、品質の低いコードを生成

**教訓**
- ツールを与えるだけでは不十分
- **使い方のトレーニング**と**品質検証プロセス**が必要

---
<!-- _class: font-xsmall -->

### 失敗例② GitClear社調査（2025年）- コード品質の劣化

**研究概要**
- **2億1,100万行**のコード変更を分析（2020年1月〜2024年12月）
- 対象：GitHubトップ25 OSS + 商用プロジェクト、史上最大規模の縦断調査
- 4指標を追跡：Added、Deleted、Moved、Copy/Pasted

**コード品質の測定方法**
- **Moved（移動）** = リファクタリングの代理指標
  - コードを適切な場所に移動 = 設計改善の証拠
  - 2020年：全変更の**24.1%**がMoved → 健全なリファクタリング文化
- **Copy/Pasted** = コード重複の代理指標（技術的負債の蓄積）

---
<!-- _class: font-xsmall -->

### 失敗例② GitClear社調査（続き）- 衝撃のデータ

**Copilot登場後の変化（2022年以降）**
- Moved比率：24.1%（2020年）→ **9.5%**（2024年）← 60%減少
- 2024年：初めて**MovedをCopy/Pastedが上回った**
- コード重複ブロック（5行以上）：**8倍増加**
- コードチャーン（2週間以内の修正）：3.1% → **5.7%**

**専門家の警告（Bill Harding, GitClear CEO）**
- 「AIは既存コードを再利用する代わりに、新しいコードをコピペで生成」
- 「35年のキャリアで、これほど短期間に技術的負債が蓄積されるのを見たことがない」

**2025年予測**：リファクタリングは全変更の**3%以下**に、技術的負債の「臨界点」に到達する恐れ

---
<!-- _class: font-xsmall -->

### 失敗例③ Google DORA 2025 - AIは組織を増幅する

**調査概要（DORA = DevOps Research and Assessment）**
- **約5,000人**の技術者を対象とした大規模調査
- Google Cloud主導、業界標準のDevOpsメトリクス調査（10年目）
- AI採用率：**90%**（前年比14%増）
- 開発者は1日平均**2時間**AIツールを使用

**ポジティブな発見**
- 80%以上が「生産性向上」を実感
- 開発スループット：向上傾向
- AIを活用するチームほど**プラットフォームエンジニアリング**に投資

---
<!-- _class: font-xsmall -->

### 失敗例③ Google DORA 2025（続き）- 増幅効果の罠

**ネガティブな発見：安定性の低下**
- ソフトウェア配信の**安定性は低下**、**30%がAI生成コードを「信頼していない」**
- 変更失敗率（Change Failure Rate）が上昇傾向

**重要な発見：AIは「増幅器」**
- AIは組織の**強みも弱みも増幅する**
- 自動テスト・CI/CDが弱い組織 → AI導入で不安定化が加速
- 基盤が強い組織 → AI導入で大幅な生産性向上

**成功の条件（DORA提言）**
- **プラットフォームエンジニアリング**への投資、自動テスト・CI/CDの整備が先
- AIは「銀の弾丸」ではなく「増幅器」として理解する

**Stack Overflow 2025調査**：66%が「AIはほぼ正しいが完全ではない」、45%が「デバッグに時間がかかる」

---
<!-- _class: font-xsmall -->

### 失敗例④ エンジニアのバーンアウト（2024年調査）

**調査概要**：604人の開発者対象、AI導入組織（61%）と非導入組織を比較

**深刻な結果**
- **65%がバーンアウトを経験**（AI導入の有無に関わらず）
- 43%：「経営層は現場の課題を理解していない」
- 37%：「効率性・予測可能性・生産性が過去1年で低下」

**AIがバーンアウトを悪化させる理由（Harness調査）**
- 95-98%：「AIでバーンアウトが減る」と**期待**
- **67%**：「AI生成コードのデバッグに**より多くの時間**がかかる」（現実）
- **68%**：「AI関連のセキュリティ問題の修正に**より多くの時間**」（現実）

**結論**：AIは銀の弾丸ではない。正しい使い方を学ばないと逆効果

---

## AIの5つの特性を理解する

**なぜ特性を理解するのか？** → 前スライドの失敗例（エラー率2倍、コード重複8倍）は、AIの特性を知らずに使った結果です。特性を理解すれば、対策を打てます。

---
<!-- _class: font-xsmall -->

### AIが持つ5つの特性（1/2）

**1. 暴走（Scope Creep）**
- Issue範囲外の機能を勝手に追加
- 本質的対策：仕様書で機能範囲を明確化、受入基準で「完了」を定義

**2. 手抜き（Test Hacking）**
- テストを通すだけの仮実装
- 本質的対策：受入基準を具体的かつ厳密に記述、テストケースを事前に明記

**3. 忘れっぽさ（Context Loss）**
- 過去の指示を忘れる、コンテキスト汚染
- 本質的対策：CLAUDE.mdに永続ルール記載、**Claude Skills**で再利用可能な知識を定義

---
<!-- _class: font-small -->

### AIが持つ5つの特性（2/2）

**4. 凸凹知能（Jagged Intelligence）**
- 得意分野と苦手分野の差が激しい
- 本質的対策：人間がAIの能力限界を理解し、適切な期待値を持つ

**5. 虚偽報告（Hallucination）**
- 自信満々に誤った情報を提供
- 本質的対策：自動テスト（pytest, ruff, pyright）、公式ドキュメント確認

---
<!-- _class: font-small -->

### AIの特性への対策まとめ

| 特性 | 問題 | 本質的対策 |
|------|------|------|
| 暴走 | 機能追加しすぎ | 仕様書・受入基準で範囲を明確化 |
| 手抜き | テストだけ通す | 受入基準・テストケースを事前定義 |
| 忘れっぽさ | 指示を忘れる | CLAUDE.md・Claude Skills・/clear |
| 凸凹知能 | 得意不得意が激しい | 人間が期待値を適切に管理 |
| 虚偽報告 | 誤った情報 | pytest/ruff/pyright、公式ドキュメント |

**重要**: これらの特性を理解して対策すれば、AIは強力なパートナーになる

---

## AIとの付き合い方：3つの原則

**5つの特性への対策を、覚えやすい3つの原則に整理します。** これを守れば、前述の5特性すべてに対処できます。

---
<!-- _class: font-xsmall -->

### 原則1: Trust but Verify（信頼しつつ検証する）

**AIは優秀だが完璧ではない**
- テストは通るが本番で動かない
- 「完成しました！」と報告するが実際は不完全
- 自信満々に誤った情報を提供する

**対策：3段階レビュー**
1. 自動検証（pytest && ruff check && pyright）
2. AI自己検証（「100点満点で評価して」）
3. 人間レビュー（git diff確認）

---
<!-- _class: font-xsmall -->

### Trust but Verify の起源

**レーガン大統領と核軍縮交渉**
- 1987年、米ソ間の中距離核戦力全廃条約（INF条約）
- レーガン大統領がロシアのことわざを引用
- 「Doveryay, no proveryay」（信頼せよ、されど検証せよ）

**AI開発への適用**
- AIは優秀なパートナーだが、盲目的な信頼は危険
- 出力は必ず検証する
- 検証プロセスを仕組み化する（自動テスト、レビュー）

**「信頼」と「検証」のバランス**
- 過度な不信：AIの恩恵を受けられない
- 過度な信頼：品質低下、障害のリスク
- 適切なバランス：効率と品質の両立

---
<!-- _class: font-xxsmall -->

### 原則2: Context is the New Code（コンテキストが全て）

**AIは外部メモリが必要**（コンテキストは有限）
- **設計書なし**：コード読解にトークンを使いすぎ → 思考リソース不足
- **設計書あり**：設計書は情報密度が高い → 十分な思考リソースを確保

**コンテキストの種類**
- CLAUDE.md：プロジェクトルール（Claudeが最初に読む）
- README.md：プロジェクト概要
- 設計書：画面、DB、API仕様 / Issue：タスク定義 / 受入基準（AC）

**研究データ**
- TiCoder（Microsoft Research）：テスト駆動で**ユーザー意図との整合性90.4%**達成
- McKinsey 2024：ドキュメント作成**45-50%削減**、コード作成**35-45%短縮**
- PMI調査：プロジェクト失敗の**47%**は要件定義の問題が原因

---
<!-- _class: font-xsmall -->

### Context is the New Code - 研究データ①

**TiCoder（Microsoft Research 2022-2024）**
- テスト駆動型のユーザー意図明確化フレームワーク
- **ユーザー意図との整合性：90.4%**（自然言語入力から）
- pass@1精度：48.39% → **70.49%**（45%向上）
- わずか**1.69回**の対話でユーザー意図を正確に把握
- 「曖昧な自然言語の意図をテストで形式化」することで精度向上

**μFiX（ICSE 2025発表）**
- LLMの「仕様誤解」を修正するプロンプト技術
- ChatGPT、DeepSeek-Coderなど6つのベンチマークで検証
- 仕様理解の改善 → コード生成性能が大幅向上

---
<!-- _class: font-xxsmall -->

### Context is the New Code - 研究データ②

**McKinsey 2024（開発者生産性調査）**
- ドキュメント作成：**45-50%削減** / コード作成：**35-45%短縮**
- 高パフォーマー：品質**31-45%向上**、市場投入**16-30%短縮**
- ただし「生成コードの大部分は修正が必要」→ レビュー能力が重要

**Harvard/BCG 2023（758人の実験）**
- GPT-4使用：タスク完了**12.2%増**、速度**25.1%向上**、品質**40%向上**
- 「凸凹フロンティア」外では正解率**19ポイント低下** → 得意・不得意の見極めが鍵

**PMI/業界調査**
- プロジェクト失敗の**47%**は要件定義の問題が原因
- 要件エラーは本番修正で設計時の**10-100倍**のコスト
- 設計2時間投資 → 実装時間70%削減

---
<!-- _class: font-xxsmall -->

### 原則3: 段階的に進める

**なぜ段階的に進めるのか**
- コンテキストには上限があり、長いタスクでは途中でcompact（情報切り捨て）が発生
- 長いタスクは暴走・手抜き・忘れるリスク増大
- 小さなステップで品質を維持

**具体例：ユーザー認証機能**

❌ 悪い例（大きすぎる）:「ユーザー認証機能を実装して」

✅ 良い例（段階的）:
1. Userモデルを作成（10分）
2. パスワードハッシュ化を実装（10分）
3. ログインエンドポイントを作成（10分）
4. JWTトークン発行を実装（10分）

**効果**: 各ステップで品質確認、問題の早期発見、進捗が明確

---

## Claude Codeとは：AI駆動開発のツール

**3つの原則を実践するためのツールがClaude Codeです。** CLAUDE.mdでコンテキストを与え、段階的にタスクを実行し、検証を自動化できます。

---
<!-- _class: font-xsmall -->

### Claude Codeの基本

**Claude Codeとは**
- AnthropicのCLIツール（コマンドライン上で動作）
- Claude AIとの対話でコード開発を行う
- ファイル読み書き、コマンド実行が可能

**3つの重要ファイル**
- CLAUDE.md：プロジェクトのルール（Claudeが最初に読む）
- README.md：プロジェクト概要
- .claude/commands/：カスタムコマンド格納場所

**特徴**
- 大容量のコンテキストで長い会話を維持
- ファイル検索・編集・テスト実行を自動化
- チャット履歴を保持してコンテキストを維持

---
<!-- _class: font-xsmall -->

### Claude Skills とは

**Skills の概念**
- AIの能力を拡張するための設定ファイル
- `.claude/skills/` ディレクトリに配置
- 特定のタスクに特化した指示を定義

**Skills の種類**
- コード生成スキル: 言語やフレームワーク固有のルール
- 品質管理スキル: テスト、レビューの自動化
- ドキュメントスキル: 仕様書、README生成

**忘れっぽさへの対策**
- CLAUDE.mdだけでは伝えきれない詳細なルールを保存
- タスク種別ごとに最適な指示を再利用可能
- プロジェクト固有の知識を永続化

---
<!-- _class: font-xxsmall -->

### コンテキストとトークンの理解

**トークンとは**
- テキストの単位（日本語：約1.5文字/トークン、英語：約4文字/トークン）
- AIのコンテキストには上限がある（会話が長くなると古い情報は忘れる）

**コンテキストの使われ方**
- **読み込み** + **思考・生成** = 合計（固定）
- コード読解が多いほど、思考リソースが減る
- 設計書は情報密度が高く、効率的

**だから設計書が重要**
- 設計書があればAIの思考リソースを確保できる
- コード全体を読む必要がなくなる

---
<!-- _class: font-xxsmall -->

### Claude Codeの4つのモード

**Normal（通常モード）**
- 慎重に動作、ユーザーに確認を取る
- ファイル変更前に許可を求める
- 初心者向け、安全重視

**Plan（プランモード）**
- 実装前に計画を立てる
- タスクを分解して提示
- 承認後に実装開始

**Yolo（高速モード）**
- 確認なしで高速実行
- 危険な操作も即実行
- 上級者向け、スピード重視

**Bypass Permissions（権限バイパス）**
- ファイル操作の許可を自動承認
- 繰り返し作業の効率化

---
<!-- _class: font-xxsmall -->

### カスタムコマンド: TDDサイクル

**カスタムコマンドとは**
- よく使う指示を登録して再利用
- `.claude/commands/` に保存
- `/コマンド名` で実行

**TDDサイクル用コマンド**
- `/tdd-plan`：実装計画を立てる
- `/tdd-red`：失敗するテストを書く
- `/tdd-green`：テストを通す最小実装
- `/tdd-refactor`：コードを改善
- `/tdd-verify`：完成度を検証

**使用例**
```bash
/tdd-plan ユーザー認証機能
/tdd-red ログイン機能のテストを書いて
/tdd-green テストを通して
/tdd-refactor コードを改善して
```

---
<!-- _class: font-xsmall -->

### CLAUDE.mdとREADME.md

**CLAUDE.md（最重要）**
- Claudeが最初に読むプロジェクトルール
- コーディング規約、アーキテクチャ方針を記載
- 例：「テストカバレッジ80%以上必須」「実装前に不明点があれば質問すること」

**README.md**
- プロジェクト概要、セットアップ方法
- 人間とAI両方が読む
- プロジェクトの全体像を把握

**効果**
- CLAUDE.mdがあれば、毎回同じ指示を繰り返さなくていい
- プロジェクト全体で一貫した品質を保てる
- 新しいタスクでもルールを自動適用

---
<!-- _class: font-xsmall -->

### CLAUDE.md のディレクトリ別配置

**モノレポでの活用**（モノレポ = 1つのリポジトリで複数プロジェクトを管理する手法）
```
project/
├── CLAUDE.md       ← 全体ルール
├── frontend/CLAUDE.md  ← フロントエンド固有
├── backend/CLAUDE.md   ← バックエンド固有
└── tests/CLAUDE.md     ← テスト固有
```

**ディレクトリ別ルールの例**
- frontend/: React、biome
- backend/: Python、ruff/pyright
- tests/: pytest、80%カバレッジ

---
<!-- _class: font-xsmall -->

### AIにあいまいな点を明確化させる

**問題：AIは推測で進める**
- 技術スタック未定義 → 勝手にライブラリを選択
- テスト方法不明 → ハードコードで済ませる

**CLAUDE.mdに記載する指示**
```markdown
実装前に、以下について不明点があれば必ず質問してください：
- 使用する技術スタック・ライブラリ
- テスト方法とカバレッジ目標
```

**AIからの質問例**
- 「Webフレームワークは？（FastAPI / Django / Flask）」
- 「DBは？（PostgreSQL / SQLite / MySQL）」

**効果**: 技術選定のミスマッチ防止、一貫性、手戻り削減

---

## AI駆動開発の5-STEPワークフロー

---
<!-- _class: font-xsmall -->

### 5-STEPの全体像と効果

**5つのステップ**
1. **要件定義**（STEP 1）：誰が、何を、なぜ（ユーザーストーリー、MoSCoW分析）
2. **設計**（STEP 2）：AIの外部メモリ構築（画面、DB、AC、API仕様）
3. **タスク分解**（STEP 3）：10分サイズに分割（GitHub Issues、BDD）
4. **実装**（STEP 4）：TDD + 3段階レビュー（Red-Green-Refactor + 検証）
5. **品質改善**（STEP 5）：AIに任せる（リファクタリング、ドキュメント）

**目的**
- AIの5つの特性（暴走、手抜き、忘れっぽさ、凸凹知能、虚偽報告）を制御
- 高品質なコードを効率的に生成、人間とAIの役割分担を明確化

---
<!-- _class: font-xsmall -->

### 5-STEPと人間・AIの役割分担

| STEP | 人間の役割 | AIの役割 | 防ぐAI特性 |
|------|-----------|----------|-----------|
| 1. 要件定義 | ユーザーストーリー作成 | 妥当性検証 | 暴走 |
| 2. 設計 | 画面・DB・AC定義 | 設計レビュー | 忘れっぽさ、凸凹知能 |
| 3. タスク分解 | 10分タスクに分割 | BDDシナリオ作成 | 暴走、忘れっぽさ |
| 4. 実装 | 人間レビュー | TDD実装 | 手抜き、虚偽報告 |
| 5. 品質改善 | 最終確認 | リファクタリング | - |

**効果**
- 設計への投資で実装時間70%削減（10時間→3時間）
- 5-STEPで、AIの特性を制御し、高品質なコードを効率的に生成

---

## 今日の学習内容

---
<!-- _class: font-xsmall -->

### 3つのセッション

**02: STEP 1-2-3**
- 要件定義・設計・タスク分解
- ユーザーストーリー、画面設計、受入基準
- Planモード、AIに質問させる手法

**03: STEP 4-5**
- TDD実装・3段階レビュー
- Test Hacking対策、/clearでコンテキスト管理
- MCP Servers活用、品質改善

**04: 統合ハンズオン**
- STEP 1-5の完全実践
- TODO管理アプリ実装

---
<!-- _class: font-small -->

### AI駆動開発で大切なこと（1/2）

**マインドセット**
1. AIを信頼しつつ検証する（3段階レビュー）
2. コンテキスト（設計書）に投資する（3.4倍の効果）
3. 段階的に進める（10分ルール）

**覚えておくこと**
- AIは優秀だが完璧ではない（エラー率2倍のリスク）
- 設計書があればAIは3倍賢くなる
- Planモードで早期軌道修正（手戻り54%削減）

---
<!-- _class: font-xsmall -->

### AI駆動開発で大切なこと（2/2）

**覚えておくこと（続き）**
- `/clear`でコンテキスト汚染を防ぐ
- AIに質問させる（暴走・手抜き・忘れっぽさを防ぐ）

**成功の条件**
- 正しく使えば最大10倍の生産性向上
- 間違えるとコード重複8倍、レビュー負担91%増加
- 5-STEPワークフローで品質と速度の両立

**これから**
- 02で実際に設計書を作成します
- 03でTDD実装を体験します
- 04で全体を通して実践します

---

## 質問タイム

準備ができたら、02に進みましょう！
